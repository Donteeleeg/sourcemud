// Character Creation for AweMUG NG
// Copyright (C) 2003  AwesomePlay Productions, Inc.

// configuration
var STAT_TOKENS = 6; // how many 'tokens' the player can spend on stats
var STAT_POINTS = 160; // how many stat points the player gets randomly assigned
var STAT_INC = 5; // the increment stats have when randomly distributed, and when tokens are used
var STAT_BASE = 30; // base value of all stats, before point distribution
var STAT_MAX = 90; // maximum stat can be raised to in character creation

// states
var STATE_RACE = 0;
var STATE_RACE_CONFIRM = 1;
var STATE_ALIGN = 2;
var STATE_STATS = 3;
var STATE_STATS_CONFIRM = 4;
var STATE_GENDER = 5;
var STATE_TRAITS = 6;
var STATE_HEIGHT = 7;
var STATE_DETAIL_CONFIRM = 8;
var STATE_FINAL_CONFIRM = 9;
var STATE_DONE = 10;

// get a race
function getRace(line)
{
	// numeric?
	var num = line.toInt();

	// named?
	foreach (var race in getPlayerRaces()) {
		// numeric form
		if (num > 0 && num-- == 1)
			return race;
		// name form
		else if (line.matches(race.getName()))
			return race;
	}

	// no race
	return nil;
}

// display race in detail
function displayRace(player, race)
{
	player.print ("Race: ", race.getName(), "\n");
	player.setIndent(2);

	// Stats
	for (var i = 0; i < STAT_COUNT; ++i) {
		if (race.getStat(i) != 0) {
			player.print (getStatName(i), ':');
			player.setIndent(16);
			if (race.getStat(i) > 0)
				player.print ('+');
			player.print (race.getStat(i), "\n");
			player.setIndent(2);
		}
	}

	// Lifespan
	player.print("Life span:");
	player.setIndent(16);
	player.print(race.getLifeSpan(), " years\n");

	// About
	player.setIndent(0);
	player.print("\n", CDESC, race.getAbout(), CNORMAL, "\n\n");
}

// display various details
function displayDetails(player)
{
	player.print("Description:\n  ", strParse("{$1.Desc}", player), "\n\n");
}

// entered yes?
function isYes(line)
{
	// yes?
	if (line.matches('yes'))
		return 1;
	// no?
	if (line.matches('no'))
		return -1;
	// neither
	return 0;
}

new CreationProcessor : Processor {
	// initialize the processor
	init(player)
	{
		// store all available traits here
		self.all_traits = getTraits();
		message(self.all_traits.length());

		// setup
		self.player = player;
		self.startState(0);

		return 1; // success
	}

	// finish up
	close(player)
	{
	}

	// update handler
	update(player, line)
	{
		line = line.lower();

		// reset handler?
		if (line == 'restart') {
			player.print("\n\nRestarting character creation.");
			self.init(player);
			return 0;
		}

		// quit or exit?
		if (line == 'quit' || line == 'exit') {
			return 1;
		}

		// new state
		var state = self.state;

		// update 
		if (state == STATE_RACE) { // race
			// help?
			if (line.matches('help')) {
				self.showState();
				player.exec('help charcreate-race');
				return 0;
			}

			// lookup race
			self.race = getRace(line);
			if (self.race) {
				++state;
			} else {
				self.showState();
			}
		} else if (state == STATE_RACE_CONFIRM) { // confirm
			// said yes?
			var choice = isYes(line);
			if (choice > 0) {
				player.setRace(self.race);
				++state;
			} else if (!line || choice < 0) { // default
				// back to race selection
				state = STATE_RACE;
			}
		} else if (state == STATE_GENDER) { // gender
			var gender = line.toInt();
			// check gender
			if (gender == GENDER_MALE || gender == GENDER_FEMALE) {
				player.setGender(gender);
				++state;
			} else if (line.matches('female')) {
				player.setGender(GENDER_FEMALE);
				++state;
			} else if (line.matches('male')) {
				player.setGender(GENDER_MALE);
				++state;
			} else {
				self.showState();
			}
		} else if (state == STATE_TRAITS) { // select traits
			var trait = line.toInt() - 1;
			if (trait < 0 || trait >= self.cur_traits.length()) {
				self.showState();
				return 0;
			}

			player.setTrait(self.all_traits[self.trait], self.cur_traits[trait]);
			self.nextTrait();
			if (self.trait == -1)
				++state;
			else
				self.showState();
		} else if (state == STATE_HEIGHT) { // player height
			// help?
			if (line.matches('help')) {
				self.showState();
				player.exec('help charcreate-height');
				return 0;
			}

			var adjust = 0;
			var ok = 0;

			var num = line.toInt();
			if (num == 2 || line.matches('short')) {
				adjust = -6;
				ok = 1;
			} else if (num == 1 || line.matches('very short')) {
				adjust = -12;
				ok = 1;
			} else if (num == 4 || line.matches('tall')) {
				adjust = 6;
				ok = 1;
			} else if (num == 5 || line.matches('very tall')) {
				adjust = 12;
				ok = 1;
			} else if (num == 3 || line.matches('average')) {
				adjust = 0;
				ok = 1;
			} else {
				self.showState();
			}

			if (ok) {
				++state;

				var height = self.player.getRace().getAverageHeight(self.player.getGender()) - 3 + getRandom(7) + adjust;
				self.player.setHeight(height);
			}

		} else if (state == STATE_ALIGN) { // alignment
			// help?
			if (line.matches('help')) {
				self.showState();
				player.exec('help charcreate-align');
				return 0;
			}

			num = line.toInt();
			if (num == 1 || line.matches('good')) { // good
				player.setAlignment(400);
				++state;
			} else if (num == 2 || line.matches('neutral')) { // neutral
				player.setAlignment(0);
				++state;
			} else if (num == 3 || line.matches('evil')) { // evil
				player.setAlignment(-400);
				++state;
			} else {
				self.showState();
			}
		} else if (state == STATE_STATS) { // stats
			// help?
			if (line.matches('help')) {
				self.showState();
				player.exec('help charcreate-stats');
				return 0;
			}

			// empty line?
			if (!line) {
				self.showState();
				return 0;
			}

			// reroll?
			if (line == 'roll' || line == 'reroll') {
				// slight hack
				self.startState(STATE_STATS);
				return 0;
			}

			// check stat
			var stat = line.toInt() - 1;
			if (stat < 0 || stat >= STAT_COUNT) {
				// not a number, a name?
				for (stat = 0; stat < STAT_COUNT; ++stat) {
					if (line.matches(getStatName(stat)))
						break;
				}
				// didn't find a named stat
				if (stat == STAT_COUNT) {
					self.showState();
					return 0;
				}
			}

			// stat maxed out?
			if (player.getBaseStat (stat) >= STAT_MAX) {
				self.showState();
				player.print("You cannot increase that statistic any further.\n\n");
				return 0;
			}

			// do work
			player.setBaseStat (stat, player.getBaseStat (stat) + STAT_INC);
			self.tokens = self.tokens - 1;
			player.recalcStats();

			// out of tokens?
			if (self.tokens == 0) {
				state = STATE_STATS_CONFIRM;
			} else {
				self.showState();
				player.print("You have ", self.tokens, " tokens left.\n\n");
			}
		} else if (state == STATE_STATS_CONFIRM) { // confirm
			// said yes?
			choice = isYes(line);
			if (!line || choice > 0) { // default
				++state;
			} else if (choice < 0) {
				state = STATE_STATS;
			} else {
				self.showState();
			}
		} else if (state == STATE_DETAIL_CONFIRM) { // confirm details
			// said yes?
			choice = isYes(line);
			if (!line || choice > 0) { // default
				++state;
			} else if (choice < 0) {
				// back to detail selection
				state = STATE_GENDER;
			}
		} else if (state == STATE_FINAL_CONFIRM) { // confirm character
			// said yes?
			choice = isYes(line);
			if (!line || choice > 0) { // default
				++state;
			} else if (choice < 0) {
				// start over
				state = 0;
			}
		}

		// all done, there is no more
		if (state == STATE_DONE) {
			// make valid
			player.validate();

			// exit
			return 1;
		// next state
		} else if (state != self.state) {
			self.startState(state);
		}

		return 0;
	}

	// roll stats
	rollStats()
	{
		var player = self.player;
		var points = STAT_POINTS;

		// initialize
		for (var i = 0; i < STAT_COUNT; ++ i)
			player.setBaseStat (i, STAT_BASE);

		// distribute randomness
		while ((points -= STAT_INC) > 0) {
			var stat = getRandom(STAT_COUNT);
			player.setBaseStat (stat, player.getBaseStat(stat) + STAT_INC);
		}

		// recalc
		player.recalcStats();
	}

	// begin a new state
	startState(state)
	{
		self.state = state; // store state
		
		if (state == STATE_STATS) { // stats
			// tokens
			self.tokens = STAT_TOKENS;
			self.rollStats();
		} else if (state == STATE_TRAITS) { // traits
			self.trait = -1;
			self.nextTrait();
			if (self.trait == -1)
				self.startState(state + 1);
		} else if (state == STATE_FINAL_CONFIRM) { // finish
			// set birthday
			var birthdate = getTime();
			birthdate.setYear (birthdate.getYear() - self.player.getRace().getRandAge());
			self.player.setBirthday(birthdate);

			// give 'em some coins
			self.player.giveCoins(500);

			// finish final calculations
			self.player.recalc();
			self.player.setHp(self.player.getMaxhp());
		}

		self.showState();
	}

	// show state header
	showState()
	{
		self.player.clearScr();
		self.player.print(	"Character Creation\n", 
							"------------------\n",
							"Name: ", self.player, "\n\n");
		
		if (self.state == STATE_RACE) { // race
			self.player.print(
				"Your race, or species, defines what kind of being you are.  Different races have ",
				"different physical, mental, and spiritual strengths.\n\n");
			self.showRaces();
			self.setPrompt("Select race:");
		} else if (self.state == STATE_RACE_CONFIRM) {
			displayRace(self.player, self.race);
			self.setPrompt("Keep race? (y/N)");
		} else if (self.state == STATE_GENDER) { // gender
			self.showGenders();
			self.setPrompt("Select gender:");
		} else if (self.state == STATE_TRAITS) {
			self.showTraits();
			self.setPrompt("Select " :: self.all_traits[self.trait] :: ":");
		} else if (self.state == STATE_HEIGHT) { // height
			self.player.printf(
				"The average height for a {$1.gender} {$1.race} is " ::
				self.player.getRace().getAverageHeight(self.player.getGender()) ::
				" inches, give or take three.\n\n");
			self.player.print("Height Adjustment:\n");
			self.player.print("  1) Very short (12 inches shorter)\n");
			self.player.print("  2) Short (6 inches shorter)\n");
			self.player.print("  3) Average (normal average)\n");
			self.player.print("  4) Tall (6 inches taller)\n");
			self.player.print("  5) Very tall (12 inches taller)\n\n");
			self.setPrompt("Select height:");
		} else if (self.state == STATE_ALIGN) { // alignment
			self.player.print(
				"Your alignment is an indication of your moral and ethical beliefs.  Good characters ",
				"believe in doing what is right and just, even at their own expense.  Evil characters ",
				"will often use excessively cruel tactics to reach their goals.  Neutral characters ",
				"are in the middle of the two extremes.\n\n");
			self.player.print("Alignments:\n");
			self.player.print("  1) Good\n");
			self.player.print("  2) Neutral\n");
			self.player.print("  3) Evil\n\n");
			self.setPrompt("Select alignment:");
		} else if (self.state == STATE_STATS) { // stats
			self.player.print(
				"You have ", self.tokens, " tokens with which to increase your character ",
				"attributes.  Each token increases an attribute by ", STAT_INC, " points.  ",
				"Your base attributes are determined randomly; all characters will have the ",
				"same total of attribute points, however.  You may at any time reroll your ",
				"stats by typing 'reroll'.\n\n");
			self.player.showStats();
			self.setPrompt("Increase stat:");
		} else if (self.state == STATE_STATS_CONFIRM) {
			self.player.showStats();
			self.setPrompt("Keep stats? (Y/n)");
		} else if (self.state == STATE_DETAIL_CONFIRM) {
			displayDetails(self.player);
			self.setPrompt("Keep details? (Y/n)");
		} else if (self.state == STATE_FINAL_CONFIRM) {
			self.player.showInfo();
			self.player.print("\n");
			self.setPrompt("Accept new character? (Y/n)");
		}
	}

	// list races
	showRaces()
	{
		var index = 1;
		self.player.print("Available races:\n");
		foreach(var race in getPlayerRaces()) {
			self.player.print('  ', index++, ') ', capwords(race.getName()), "\n");
		}
	}

	// list genders
	showGenders()
	{
		self.player.print("Available genders:\n");
		self.player.print("  1) Female\n");	// GENDER_FEMALE=1
		self.player.print("  2) Male\n");	// GENDER_MALE=2
	}

	// list trait values
	showTraits()
	{
		self.player.print("Available ", self.all_traits[self.trait], " choices:\n");
		var num = 1;
		foreach (var trait in self.cur_traits)
			self.player.print("  ", num++, ") ", capwords(trait), "\n");
	}

	// select next valid trait
	nextTrait()
	{
		// next trait; increment
		// FIXME: self.trait++ gives 'not a structure' error... odd
		self.trait = self.trait + 1;

		// no more?
		if (self.trait >= self.all_traits.length()) {
			self.trait = -1;
			return;
		}

		// get traits and number of traits
		self.cur_traits = self.race.getTraitValues(self.all_traits[self.trait]);
		var count = self.cur_traits.length();

		// race has none for this trait?  skip
		if (count == 0) {
			self.nextTrait();
			return;
		}

		// race has only for value for this trait?  set and skip
		if (count == 1) {
			self.player.setTrait(self.all_traits[self.trait], self.cur_traits[0]);
			self.nextTrait();
			return;
		}
	}
}

// attach the character creation hook
function createCharacter(player)
{
	player.addProc(new CreationProcessor);
}

// player starting location
function playerStart(player)
{
	player.enter(getRoom('altar'), nil);
}

// register hooks
function init() {
	registerHook('player_start', playerStart);
	registerHook('create_character', createCharacter);
}
