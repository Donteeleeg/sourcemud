<?xml version="1.0"?>
<script-interface>
  <!-- header code -->
  <header><![CDATA[
    #include <stdlib.h>

    #include <sstream>
    
    #include "mud/zone.h"
    #include "mud/player.h"
    #include "mud/npc.h"
    #include "mud/room.h"
    #include "mud/body.h"
    #include "mud/server.h"
    #include "mud/command.h"
    #include "common/streams.h"
    #include "mud/color.h"
    #include "mud/telnet.h"
    #include "mud/zmp.h"
    #include "mud/account.h"
    #include "mud/parse.h"
    #include "mud/race.h"
    #include "common/rand.h"
    #include "mud/object.h"
    #include "mud/portal.h"
    #include "mud/creature.h"
    #include "mud/hooks.h"
    #include "common/strbuf.h"
    #include "mud/http.h"

    using namespace std;
  ]]></header>
  <footer/>

  <!-- Global constants - SYSTEM STUFF -->
  <global-group>
    <name>System Values</name>
    <doc>Various internal system values.  These are used in all parts of AweMUD.</doc>

    <global>
      <name>TICKS_PER_ROUND</name>
      <type>Integer</type>
      <doc>Number of game ticks per game round.</doc>
    </global>
    <global>
      <name>true</name>
      <type>Integer</type>
      <expr>1</expr>
      <doc>Use this whenever you need to supply a "true" boolean value.  Do *not* use this for comparison.</doc>
      <example>// good
if (value) { ... }

// bad
if (value == true) { ... }</example>
    </global>
    <global>
      <name>false</name>
      <type>Integer</type>
      <expr>0</expr>
      <doc>Use this whenever you need to supply a "false" boolean value.  Do *not* use this for comparison.</doc>
      <example>// good
if (!value) { ... }

// bad
if (value == false) { ... }</example>
    </global>
  </global-group>

  <!-- Global constants - COLORS -->
  <global-group>
    <name>Colors</name>
    <doc>These values are color codes that can be inserted into text sent out to players.  These values should not be inserted into strings intended to be stored long term or used anywhere other than player output.</doc>

    <global>
      <name>CNORMAL</name>
			<expr>S(CNORMAL)</expr>
      <type>String</type>
      <doc>Normal color code.</doc>
    </global>
    <global>
      <name>CPLAYER</name>
			<expr>S(CPLAYER)</expr>
      <type>String</type>
      <doc>Color code for player names.</doc>
    </global>
    <global>
      <name>CNPC</name>
			<expr>S(CNPC)</expr>
      <type>String</type>
      <doc>Color code for npc names.</doc>
    </global>
    <global>
      <name>CEXIT</name>
			<expr>S(CEXIT)</expr>
      <type>String</type>
      <doc>Color code for portals.</doc>
    </global>
    <global>
      <name>CTALK</name>
			<expr>S(CTALK)</expr>
      <type>String</type>
      <doc>Color code for talking.</doc>
    </global>
    <global>
      <name>CTITLE</name>
			<expr>S(CTITLE)</expr>
      <type>String</type>
      <doc>Color code for room titles.</doc>
    </global>
    <global>
      <name>CDESC</name>
			<expr>S(CDESC)</expr>
      <type>String</type>
      <doc>Color code for room descriptions.</doc>
    </global>
    <global>
      <name>CITEM</name>
			<expr>S(CITEM)</expr>
      <type>String</type>
      <doc>Color code for object names.</doc>
    </global>
    <global>
      <name>CADMIN</name>
			<expr>S(CADMIN)</expr>
      <type>String</type>
      <doc>Color code for administrator/server messages.</doc>
    </global>
  </global-group>

  <!-- Global constants - EXPERIENCE -->
  <global-group>
    <name>Experience Pools</name>

    <global>
      <name>EXP_GENERAL</name>
      <type>Integer</type>
      <doc>General experience pool.</doc>
    </global>
    <global>
      <name>EXP_WARRIOR</name>
      <type>Integer</type>
      <doc>Warrior experience pool.</doc>
    </global>
    <global>
      <name>EXP_ROGUE</name>
      <type>Integer</type>
      <doc>Rogue experience pool.</doc>
    </global>
    <global>
      <name>EXP_CASTER</name>
      <type>Integer</type>
      <doc>Caster experience pool.</doc>
    </global>
  </global-group>

  <!-- Global constants - STATS -->
  <global-group>
    <name>Creature Stats</name>

    <global>
      <name>STAT_STRENGTH</name>
      <type>Integer</type>
      <expr>CreatureStatID::STRENGTH</expr>
      <doc>Strength creature statistic.</doc>
    </global>
    <global>
      <name>STAT_FORTITUDE</name>
      <type>Integer</type>
      <expr>CreatureStatID::FORTITUDE</expr>
      <doc>Endurance creature statistic.</doc>
    </global>
    <global>
      <name>STAT_AGILITY</name>
      <type>Integer</type>
      <expr>CreatureStatID::AGILITY</expr>
      <doc>Agility creature statistic.</doc>
    </global>
    <global>
      <name>STAT_INTELLECT</name>
      <type>Integer</type>
      <expr>CreatureStatID::INTELLECT</expr>
      <doc>Intelligence creature statistic.</doc>
    </global>
    <global>
      <name>STAT_SPIRIT</name>
      <type>Integer</type>
      <expr>CreatureStatID::SPIRIT</expr>
      <doc>Spirit creature statistic.</doc>
    </global>
    <global>
      <name>STAT_WILLPOWER</name>
      <type>Integer</type>
      <expr>CreatureStatID::WILLPOWER</expr>
      <doc>Creatureisma creature statistic.</doc>
    </global>
    <global>
      <name>STAT_COUNT</name>
      <type>Integer</type>
      <expr>CreatureStatID::COUNT</expr>
      <doc>The number of stats that exist.  (Useful in loops.)</doc>
    </global>
  </global-group>

  <!-- Positions -->
  <global-group>
    <name>Creature Positions</name>
    <doc>These are for use with the <link method="Creature.position"/> and <link method="Creature.setPosition"/> methods.</doc>

    <global>
      <name>POS_STAND</name>
      <type>Integer</type>
      <expr>CreaturePosition::STAND</expr>
      <doc>Standing position.</doc>
    </global>
    <global>
      <name>POS_SIT</name>
      <type>Integer</type>
      <expr>CreaturePosition::SIT</expr>
      <doc>Sitting position.</doc>
    </global>
    <global>
      <name>POS_LAY</name>
      <type>Integer</type>
      <expr>CreaturePosition::LAY</expr>
      <doc>Laying down position.</doc>
    </global>
    <global>
      <name>POS_KNEEL</name>
      <type>Integer</type>
      <expr>CreaturePosition::KNEEL</expr>
      <doc>Kneeling position.</doc>
    </global>
  </global-group>

  <!-- Global constants - GENDER -->
  <global-group>
    <name>Genders</name>

    <global>
      <name>GENDER_NONE</name>
      <expr>GenderType::NONE</expr>
      <type>Integer</type>
      <doc>No gender (asexual).</doc>
    </global>
    <global>
      <name>GENDER_FEMALE</name>
      <expr>GenderType::FEMALE</expr>
      <type>Integer</type>
      <doc>Female gender.</doc>
    </global>
    <global>
      <name>GENDER_MALE</name>
      <expr>GenderType::MALE</expr>
      <type>Integer</type>
      <doc>Male gender.</doc>
    </global>
  </global-group>

  <!-- Entity name types -->
  <global-group>
    <name>Entity Name Types</name>
    <doc>Entity name types are used with the Entity.get_namef() method.  This method allows you to retrieve the entity's name with various formatting applied, including the prefixing of articles.  These global values are used to indicate which form of article you desire.</doc>

    <global>
      <name>EN_DEF</name>
      <type>Integer</type>
      <expr>DEFINITE</expr>
      <doc>Definite article version of entity name representation.</doc>
    </global>
    <global>
      <name>EN_INDEF</name>
      <type>Integer</type>
      <expr>INDEFINITE</expr>
      <doc>Indefinite article version of entity name representation.</doc>
    </global>
    <global>
      <name>EN_NONE</name>
      <type>Integer</type>
      <expr>NONE</expr>
      <doc>No article version of entity name representation.</doc>
    </global>
  </global-group>

  <!-- For Creature.cl_find_object -->
  <global-group>
    <name>Object Search Ranges</name>
    <doc>The <link method="Creature.clFindObject"/> method can be configured to look in different places for the named object.  For example, you may search only the ground, only the creature's inventory, or every reachable location.</doc>

    <global>
      <name>GOC_HELD</name>
      <type>Integer</type>
      <doc>Only look for held items.</doc>
    </global>
    <global>
      <name>GOC_WORN</name>
      <type>Integer</type>
      <doc>Only look for worn items.</doc>
    </global>
    <global>
      <name>GOC_EQUIP</name>
      <type>Integer</type>
      <doc>Only look for held or worn items.</doc>
    </global>
    <global>
      <name>GOC_FLOOR</name>
      <type>Integer</type>
      <doc>Only look for items on the floor.</doc>
    </global>
    <global>
      <name>GOC_SUB</name>
      <type>Integer</type>
      <doc>Only look for items in containers on the floor.</doc>
    </global>
    <global>
      <name>GOC_ROOM</name>
      <type>Integer</type>
      <doc>Only look for items on the floor or in containers on the floor.</doc>
    </global>
    <global>
      <name>GOC_ANY</name>
      <type>Integer</type>
      <doc>Look for any equipped or room item.</doc>
    </global>
  </global-group>

  <!-- Containers -->
  <global-group>
    <name>Containers</name>
    <doc><link type="Object"/>s support not only a single container, but can actually have multiple containers.  You may store objects inside, on top of, under, or behind other objects.  Various <link type="Object"/> methods require that a container be specified, and these are the globals you use to do so.</doc>

    <global>
      <name>CON_IN</name>
      <expr>ObjectLocation::IN</expr>
      <type>Integer</type>
      <doc>The 'inside' container type.</doc>
    </global>
    <global>
      <name>CON_ON</name>
      <expr>ObjectLocation::ON</expr>
      <type>Integer</type>
      <doc>The 'on' container type.</doc>
    </global>
  </global-group>

  <!-- Stream Operators -->
  <streamop>
    <name>name</name>
    <arg>
      <name>entity</name>
      <type>Entity</type>
      <doc>The Entity whose name you wish to display.</doc>
    </arg>
    <arg>
      <name>article</name>
      <type>Integer</type>
      <doc>One of EN_DEF (definite article), EN_INDEF (indefinite article), or EN_NONE (no article).</doc>
    </arg>
    <arg>
      <name>capitalize</name>
      <type>Boolean</type>
      <doc>If true, the named will have forced capitalization.  (For the beginnings of sentences.)</doc>
    </arg>
    <code><![CDATA[
      _stream << StreamName(_arg_entity, (EntityArticleUsage)_arg_article, _arg_capitalize); 
    ]]></code>
    <doc>Displays the name of the given entity.</doc>
  </streamop>
  <streamop>
    <name>indent</name>
    <arg>
      <name>indentation</name>
      <type>Integer</type>
      <doc>The number of spaces to indent all following output to.</doc>
    </arg>
    <code><![CDATA[
      _stream << StreamIndent(_arg_indentation); 
    ]]></code>
    <doc>Causes all output to be indented to the given amount.  The indentation happens at final display time.</doc>
  </streamop>
  <streamop>
    <name>ignore</name>
    <arg>
      <name>who</name>
      <type>Creature</type>
      <doc>The creature to not send output to.</doc>
    </arg>
    <doc>This streamop is only valid for streams to Rooms.  By default, all creatures in the room will receive the text streamed to a room.  Any creatures listed in the @ignore streamop will not receive text from that particular stream.</doc>
    <example><![CDATA[player.room() << @ignore(player) << @name(player, EN_DEF, true) << " laughs maniacally.\n";]]></example>
    <code><![CDATA[
      _stream << StreamIgnore(_arg_who);
    ]]></code>
  </streamop>

  <!-- Randomness -->
  <function>
    <name>rollDice</name>
    <invoke>roll_dice</invoke>
    <return>
      <type>Integer</type>
      <doc>Random result.</doc>
    </return>
    <arg>
      <name>dice</name>
      <type>Integer</type>
      <doc>Number of dice to be rolled.</doc>
    </arg>
    <arg>
      <name>sides</name>
      <type>Integer</type>
      <doc>Number of sides of each die rolled.</doc>
    </arg>
    <doc>Roll dice as [dice]d[sides]+[dice]*[sides]+[mod].</doc>
    <example><![CDATA[// roll 3 six sided dice
number = roll_dice(3, 6);]]></example>
  </function>
  <function>
    <name>getRandom</name>
    <invoke>get_random</invoke>
    <return>
      <type>Integer</type>
      <doc>Random result.</doc>
    </return>
    <arg>
      <name>range</name>
      <type>Integer</type>
      <doc>Range of values returned.  Highest possible result will be one less than the range.  Lowest possible result will be zero.</doc>
    </arg>
    <doc>Return a random number from 0 thru range-1.</doc>
  </function>

  <!-- Time/ticks -->
  <function>
    <name>getTicks</name>
    <return>
      <type>Integer</type>
      <doc>The number of ticks passed since the server started.</doc>
    </return>
    <code><![CDATA[
      _return = AweMUD::get_ticks();
    ]]></code>
    <doc>This function returns the current tick count of the server.</doc>
  </function>
  <function>
    <name>pause</name>
    <arg>
      <name>ticks</name>
      <type>Integer</type>
      <doc>Number of ticks to pause.</doc>
    </arg>
    <code/>
    <doc>Pauses the thread for the given number of game ticks.  Note that this will cause the running thread to yield.  You should only call this function in fork()'d threads; it will lock up the server if used in a fore-ground thread.  (Since no game ticks will pass.)</doc>
  </function>
  <function>
    <name>getTime</name>
    <return>
      <type>Time</type>
    </return>
    <doc>Returns the current game time.</doc>
    <code><![CDATA[
      _return = new Time(AweMUD_TimeType, TimeManager.time);
    ]]></code>
  </function>

  <!-- Player commands -->
  <function>
    <name>registerCommand</name>
    <return>
      <type>Boolean</type>
      <doc>True on success, false on error.</doc>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
      <doc>Name of the command.</doc>
    </arg>
    <arg>
      <name>usage</name>
      <type>String</type>
      <doc>Usage description for the command.</doc>
    </arg>
    <arg>
      <name>format</name>
      <type>Mixed</type>
      <doc>One or more format definitions.  May be given either as a single string (one format) or an array of strings (one or more formats).</doc>
    </arg>
    <arg>
      <name>call</name>
      <type>Function</type>
      <doc>The function to invoke when the command is used.</doc>
    </arg>
    <arg>
      <name>access</name>
      <type>String</type>
      <nullok/>
      <doc>The necessary access privilege needed to run the command.</doc>
    </arg>
    <code><![CDATA[
      Command *command = new Command (_arg_name, _arg_usage, AccessID::create(_arg_access));
      if(command == NULL)
        return Scriptix::Nil;
      if (_arg_format.is_string()) {
        CommandFormat* format = new CommandFormat(command);
        format->set_callback(_arg_call);
        format->build(_arg_format.get_string());
        command->add_format(format);
      } else if (_arg_format.is_array()) {
        for (size_t i = 0; i < ((Scriptix::Array*)_arg_format.get())->get_count(); ++i) {
          CommandFormat* format = new CommandFormat(command);
          format->set_callback(_arg_call);
          if (!((Scriptix::Array*)_arg_format.get())->get_index(i).is_string()) {
            Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Member of 'format' array is not a string");
            return Scriptix::Nil;
          }
          format->build((((Scriptix::Array*)_arg_format.get())->get_index(i).get_string()));
          command->add_format(format);
        }
      } else {
        Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Argument 'format' is not a string or array");
        return Scriptix::Nil;
      }
      _return = (CommandManager.add(command) == 0);
    ]]></code>
    <doc>creates a new command with the given name.  When the command is invoked, the given function will be invoked.  The privs argument is the minimum privilege level needed to use the command.  The usage string should be a standard usage format, which each format followed by a newline (even if there is only one format).  The format argument may be either a string or an array of strings.  Each format string contains one command parsing format description.  This function returns true on success, or false on error.  (Error generally happens when a format is incorrect.)</doc>
  </function>

  <!-- Strings -->
  <function>
    <name>strParse</name>
    <return>
      <type>String</type>
      <doc>Parsed and formatted text.</doc>
    </return>
    <arg>
      <name>format</name>
      <type>String</type>
      <doc>Text format description.</doc>
    </arg>
    <varg/>
    <doc>Formats a string using entity attributes.  The string parameter is plain text with special markup in it.  Additional arguments may given, up to three.  Only <link type="Entity"/>, <link type="String"/>, or <link type="Integer"/> values may be given as the extra arguments.  The markup results in data being pulled from one of the given entities, or conditional text being displayed.</doc>
    <code><![CDATA[
      if (_argc % 2 != 1) {
        Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Arguments to 'HTTP.displayTemplate()' must be in name/value pairs.");
        return Scriptix::Nil;
      }

      ParseArgs vlist;
      String name;
      for (size_t i = 1; i < _argc; i += 2) {
        name = _argv[1].get_string();
        if (_argv[i + 1].is_a(AweMUD_EntityType)) {
          vlist[name] = ((Entity*)_argv[i + 1].get());
        } else {
          _argv[i + 1] = _argv[i + 1].to_string();
          if (!_argv[i].is_nil())
            vlist[name] = _argv[i + 1].get_string();
        }
      }

      StringBuffer buffer;
      parse::text(buffer, _arg_format, vlist);
      _return = buffer.str();
    ]]></code>
  </function>
  <function>
    <name>strMatch</name>
    <cppname>phrase_match</cppname>
    <arg>
      <name>subject</name>
      <type>String</type>
      <doc>The string to test.</doc>
    </arg>
    <arg>
      <name>test</name>
      <type>String</type>
      <doc>The base word or phrase being compared against.</doc>
    </arg>
    <return>
      <type>Boolean</type>
      <doc>Whether the subject string matches against the test phrase.</doc>
    </return>
    <code>_return = phrase_match(_arg_test, _arg_subject);</code>
    <doc>The test argument is a complete name or phrase.  The subject argument is a partial (or complete) name or phrase.  This function compares the subject against the test to see if they match.  For example, the subject 'test' matches against 'string test', but the subject 'al' does not match against the test 'numeric'.  Also note this function has been extended onto the primitive string type using the String.matches() method.</doc>
  </function>
  <function>
    <name>capwords</name>
    <arg>
      <type>String</type>
      <name>string</name>
      <doc>String to capitalize.</doc>
    </arg>
    <return>
      <type>String</type>
      <doc>Capitalized string.</doc>
    </return>
    <doc>This function will capitalize the first letter in each word in the given string.  For example, "my name is Sean" would be turned into "My Name Is Sean".</doc>
    <code>capwords(_return, _arg_string);</code>
  </function>

  <!-- System logs -->
  <function>
    <name>message</name>
    <varg/>
    <code><![CDATA[
      Scriptix::Value val;
      StringBuffer buffer;
  
      for (size_t i = 0; i < _argc; ++ i) {
        val = _argv[i];
        if (val.is_int()) {
          buffer << Scriptix::Number::to_int(val);
        } else if (val.is_string()) {
          buffer << val.get_string();
        } else if (val.is_a(AweMUD_EntityType)) {
          Entity* entity = (Entity*)val.get();
          buffer << entity;
        } else {
          buffer << val.get();
        }
      }
  
      Log::Info << buffer.str();
    ]]></code>
    <doc>Prints out the given arguments to the log file.</doc>
  </function>
  <function>
    <name>warning</name>
    <varg/>
    <code><![CDATA[
      Scriptix::Value val;
      StringBuffer buffer;
  
      for (size_t i = 0; i < _argc; ++ i) {
        val = _argv[i];
        if (val.is_int()) {
          buffer << Scriptix::Number::to_int(val);
        } else if (val.is_string()) {
          buffer << val.get_string();
        } else if (val.is_a(AweMUD_EntityType)) {
          Entity* entity = (Entity*)val.get();
          buffer << entity;
        }
      }
  
      Log::Warning << buffer.str();
    ]]></code>
    <doc>Prints out the given arguments as Warning to the log file.</doc>
  </function>
  <function>
    <name>error</name>
    <varg/>
    <code><![CDATA[
      Scriptix::Value val;
      StringBuffer buffer;
  
      for (size_t i = 0; i < _argc; ++ i) {
        val = _argv[i];
        if (val.is_int()) {
          buffer << Scriptix::Number::to_int(val);
        } else if (val.is_string()) {
          buffer << val.get_string();
        } else if (val.is_a(AweMUD_EntityType)) {
          Entity* entity = (Entity*)val.get();
          buffer << entity;
        }
      }
  
      Log::Error << buffer.str();
    ]]></code>
    <doc>Prints out the given arguments as an Error to the log file.</doc>
  </function>

  <!-- Player stats -->
  <function>
    <name>getStatName</name>
    <return>
      <type>String</type>
      <doc>Name of the creature stat.</doc>
    </return>
    <arg>
      <name>stat</name>
      <type>Integer</type>
      <doc>Index to lookup.  Must be greater than or equal to 0, and less than STAT_COUNT.</doc>
    </arg>
    <code><![CDATA[
      if (_arg_stat >= 0 && _arg_stat < CreatureStatID::COUNT)
        _return = CreatureStatID(_arg_stat).get_name();
    ]]></code>
    <doc>Returns the name for the given stat, or nil if given an invalid stat.</doc>
  </function>
  <function>
    <name>getStatColor</name>
    <invoke>get_stat_color</invoke>
    <return>
      <type>String</type>
      <doc>Color code string for the stat value.</doc>
    </return>
    <arg>
      <name>value</name>
      <type>Integer</type>
      <doc>Value of a creature stat.</doc>
    </arg>
    <doc>Returns the color control string for a statistic's value.  This is used to display "good" and "bad" color variations.</doc>
  </function>
  <function>
    <name>getStatLevel</name>
    <invoke>get_stat_level</invoke>
    <return>
      <type>String</type>
      <doc><link type="Creature"/> stat level description.</doc>
    </return>
    <arg>
      <name>value</name>
      <type>Integer</type>
      <doc>Value of a creature stat.</doc>
    </arg>
    <doc>Returns a textual description for how good or bad a statistic's value is.</doc>
  </function>
  <function>
    <name>getIntrinsicSkill</name>
    <return>
      <type>Array</type>
      <doc>An array of <link type="Skill" /> entries for all intrinsic skills.  (Also know as stats.)</doc>
    </return>
    <code><![CDATA[
      _return = new Scriptix::Array();
      const SSkillManager::SkillList& skills = SkillManager.get_skills();
      for (SSkillManager::SkillList::const_iterator i = skills.begin(); i != skills.end(); ++i)
        if ((*i)->is_intrinsic())
          _return->append(*i);
    ]]></code>
  </function>

  <!-- Game announcements -->
  <function>
    <name>announce</name>
    <arg>
      <name>text</name>
      <type>String</type>
    </arg>
    <doc>Sends the given text to all logged-on players.</doc>
    <code>ZoneManager.announce(_arg_text);</code>
  </function>

  <!-- Player traits -->
  <function>
    <name>getTraits</name>
    <return>
      <type>Array</type>
      <doc>Array of all valid trait names.</doc>
    </return>
    <code><![CDATA[
      const IDManager::IDMap& traits = CreatureTraitID::get_all();
      _return = new Scriptix::Array(traits.size(), NULL);
      for (IDManager::IDMap::const_iterator i = traits.begin(); i != traits.end(); ++i)
        _return->append(Scriptix::Value(*i));
    ]]></code>
  </function>

  <!-- Hooks -->
  <function>
    <name>registerHook</name>
    <arg>
      <type>String</type>
      <name>name</name>
      <doc>Name of the hook to register.</doc>
    </arg>
    <arg>
      <type>Function</type>
      <name>callback</name>
      <doc>Callback to be invoked whenever the hook is executed.</doc>
    </arg>
    <doc>Hooks are invocation points in the server which are executed in addition to or in place of built-in functionality.  The available hooks and the arguments they are given vary.  Some hooks are used to replace built-in functionality, such that if one or more callbacks are registered for the hook then the built-in code is ignored.  Other hooks execute in addition to the built-in code.</doc>
    <code><![CDATA[
      Hooks::add(_arg_name, _arg_callback);
    ]]></code>
  </function>

  <!-- RestrictedWriter -->
  <type>
    <name>RestrictedWriter</name>
    <cppname>ScriptRestrictedWriter</cppname>

    <method>
      <name>setInt</name>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of the attribute to set.</doc>
      </arg>
      <arg>
        <type>Integer</type>
        <name>value</name>
        <doc>Value to set the attribute to.</doc>
      </arg>
      <code><![CDATA[
        if (!_self->get_writer())
          return Scriptix::Nil;

        if (!File::valid_name(_arg_name)) {
          Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Attribute name has invalid creatures");
          return Scriptix::Nil;
        }

        _self->get_writer()->attr(S("user"), _arg_name, (long)_arg_value);
      ]]></code>
    </method>
    <method>
      <name>setString</name>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of the attribute to set.</doc>
      </arg>
      <arg>
        <type>String</type>
        <name>value</name>
        <doc>Value to set the attribute to.</doc>
      </arg>
      <code><![CDATA[
        if (!_self->get_writer())
          return Scriptix::Nil;

        if (!File::valid_name(_arg_name)) {
          Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Attribute name has invalid creatures");
          return Scriptix::Nil;
        }

        _self->get_writer()->attr(S("user"), _arg_name, _arg_value);
      ]]></code>
    </method>
    <method>
      <name>setBool</name>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of the attribute to set.</doc>
      </arg>
      <arg>
        <type>Boolean</type>
        <name>value</name>
        <doc>Value to set the attribute to.</doc>
      </arg>
      <code><![CDATA[
        if (!_self->get_writer())
          return Scriptix::Nil;

        if (!File::valid_name(_arg_name)) {
          Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Attribute name has invalid creatures");
          return Scriptix::Nil;
        }

        _self->get_writer()->attr(S("user"), _arg_name, (long)_arg_value);
      ]]></code>
    </method>
  </type>

  <!-- Entity base class -->
  <type>
    <name>Entity</name>
    <doc>Base class for all entities in AweMUD.</doc>

    <!-- Basics -->
    <method>
      <name>getName</name>
      <return>
        <type>String</type>
        <doc>The entity's name, without the article.</doc>
      </return>
      <code><![CDATA[_return = _self->get_name().get_text();]]></code>
    </method>
    <method>
      <name>getBaseName</name>
      <return>
        <type>String</type>
        <doc>The entity's name including the correct article.</doc>
      </return>
      <code><![CDATA[_return = _self->get_name().get_name();]]></code>
      <doc>An entity's base name includes an article.  For example, "an axe," "a shelf," "some glasses," and "the Heartbreaker."</doc>
    </method>
    <method>
      <name>getDesc</name>
      <return>
        <type>String</type>
        <doc>Description of the entity.</doc>
      </return>
      <invoke>get_desc</invoke>
    </method>

    <!-- tags -->
    <method>
      <name>addTag</name>
      <arg>
        <name>tag</name>
        <type>Tag</type>
      </arg>
      <code>_self->add_tag(_arg_tag->data());</code>
    </method>
    <method>
      <name>removeTag</name>
      <arg>
        <name>tag</name>
        <type>Tag</type>
      </arg>
      <code>_self->remove_tag(_arg_tag->data());</code>
    </method>
    <method>
      <name>hasTag</name>
      <arg>
        <name>tag</name>
        <type>Tag</type>
      </arg>
      <return>
        <type>Boolean</type>
        <doc>True if the Entity has the named tag, false if it does not.</doc>
      </return>
      <code>_return = _self->has_tag(_arg_tag->data());</code>
    </method>

    <!-- Formatted names -->
    <method>
      <name>getNamef</name>
      <return>
        <type>String</type>
        <doc>The entity's formatted name.</doc>
      </return>
      <arg>
        <name>article</name>
        <type>Integer</type>
        <doc>One of EN_DEF (definite article), EN_INDEF (indefinite article), or EN_NONE (no article).</doc>
      </arg>
      <arg>
        <name>capitalize</name>
        <type>Boolean</type>
        <doc>If true, the named will have forced capitalization.  (For the beginnings of sentences.)</doc>
      </arg>
      <code><![CDATA[
        StringBuffer buffer;
        buffer << StreamName(_self, (EntityArticleUsage)_arg_article, _arg_capitalize);
        _return = buffer.str();
      ]]></code>
      <doc>Returns a formatted display name.  This name will have color codes embedded, optional prefixes or suffices, and an article.  This should be used for printing out names using the <link method="Room.print"/> and Player.print() methods.</doc>
      <example><![CDATA[// set 'capitalize' to true at the beginning of a sentence
room.print(entity.get_name(EN_DEF, true), " is in the room.\n");

// indefinite articles are often times needed
player.print("You see ", entity.get_namef(EN_INDEF, false), " in the room.\n");

// on occasion, you might need to use a custom article, and have get_namef() use none
player.print("Your ", entity.get_namef(EN_NONE, false), " decays in your hand!\n");]]></example>
    </method>

    <!-- Misc. -->
    <method>
      <name>ncolor</name>
      <return>
        <type>String</type>
        <doc>Color display code for the entity.</doc>
      </return>
    </method>
    <method>
      <name>getOwner</name>
      <invoke>get_owner</invoke>
      <return>
        <type>Entity</type>
        <doc>The entity currently owning this entity, or nil if none.</doc>
      </return>
    </method>
    <method>
      <name>getRoom</name>
      <return>
        <type>Room</type>
        <doc>The room object that this entity resides in, or nil if none.</doc>
      </return>
      <doc>Most entity derivatives have parent rooms.  This method is a convenience method which allows you to easily find that room.  Most notably, <link type="Zone"/>s do not have parent rooms, and this always return nil for those.  Also, calling get_room() on a <link type="Room"/> simply returns itself.</doc>
      <code><![CDATA[
        Entity* owner = _self->get_owner();
        while (owner != NULL && !ROOM(owner))
          owner = owner->get_owner();
        if (owner != NULL)
          _return = (Room*)owner;
      ]]></code>
    </method>
    <method>
      <name>destroy</name>
      <doc>Removes the entity from its parent and deactivates the entity.</doc>
    </method>
    <method>
      <name>isActive</name>
      <invoke>is_active</invoke>
      <return>
        <type>Boolean</type>
        <doc>True is the entity is live (part of the game world) and false if the entity is deactivated (not part of the game world).</doc>
      </return>
    </method>
  </type>
  <function>
    <name>getEntitiesByTag</name>
    <return>
      <type>Array</type>
      <doc>An array of all entities with the specified tag.  If no entities match the tag, an empty array is returned.</doc>
    </return>
    <arg>
      <name>tag</name>
      <type>Tag</type>
      <doc>The tag to search for.</doc>
    </arg>
    <code><![CDATA[
      std::pair<TagTable::const_iterator, TagTable::const_iterator> list = EntityManager.tag_list(_arg_tag->data());
      if (list.first != list.second) {
        uint count = 0;
        for (TagTable::const_iterator i = list.first; i != list.second; ++i)
          ++ count;
        _return = new Scriptix::Array(count, NULL);
        if (_return) {
          count = 0;
          for (TagTable::const_iterator i = list.first; i != list.second; ++i)
            _return->append(i->second);
        }
      }
    ]]></code>
  </function>

  <!-- Generic creatures -->
  <type>
    <name>Creature</name>
    <parent>Entity</parent>
    <doc>The creature class represents the shared information between the <link type="NPC"/> and player classes.  There are also a few methods and attributes which are only useful to either the npc or player class; however, since the methods are more convenient to use without casting between this class and the true class, making them virtual methods here simplifies things.</doc>

    <!-- Stats -->
    <method>
      <name>getEffectiveStat</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>stat</name>
        <type>Integer</type>
      </arg>
      <doc>Return the curren tvalue of the specified stat.</doc>
      <code><![CDATA[
        if (_arg_stat >= 0 && _arg_stat < CreatureStatID::COUNT)
          _return = _self->get_effective_stat(_arg_stat);
      ]]></code>
    </method>
    <method>
      <name>getBaseStat</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>stat</name>
        <type>Integer</type>
      </arg>
      <doc>Get the base value of the specified stat.</doc>
      <code><![CDATA[
        if (_arg_stat >= 0 && _arg_stat < CreatureStatID::COUNT)
          _return = _self->get_base_stat(_arg_stat);
      ]]></code>
    </method>
    <method>
      <name>getStatModifier</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>stat</name>
        <type>Integer</type>
      </arg>
      <doc>Get the modifier value of the specified stat.</doc>
      <code><![CDATA[
        if (_arg_stat >= 0 && _arg_stat < CreatureStatID::COUNT)
          _return = _self->get_stat_modifier(_arg_stat);
      ]]></code>
    </method>

    <!-- Alignment -->
    <method>
      <name>getAlignment</name>
      <invoke>get_alignment</invoke>
      <return>
        <type>Integer</type>
      </return>
      <doc>Return the alignment value of the creature.  &lt;= -250 is evil.  &gt;= 250 is good.  &lt;= 300 and &gt;= -300 is neutral.</doc>
    </method>
    <method>
      <name>isEvil</name>
      <return>
        <type>Boolean</type>
      </return>
      <code>_return = _self->get_alignment().is_evil();</code>
      <doc>Return true if the creature is evil.</doc>
    </method>
    <method>
      <name>isGood</name>
      <return>
        <type>Boolean</type>
      </return>
      <code>_return = _self->get_alignment().is_good();</code>
      <doc>Return true if the creature is good.</doc>
    </method>
    <method>
      <name>isNeutral</name>
      <return>
        <type>Boolean</type>
      </return>
      <code>_return = _self->get_alignment().is_neutral();</code>
      <doc>Return true if the creature is neutral.</doc>
    </method>

    <!-- Build and inventory -->
    <method>
      <name>freeHands</name>
      <invoke>free_hands</invoke>
      <return>
        <type>Integer</type>
        <doc>Number of free hands.</doc>
      </return>
    </method>
    <method>
      <name>getHeldAt</name>
      <invoke>get_held_at</invoke>
      <return>
        <type>Object</type>
      </return>
      <arg>
        <name>index</name>
        <type>Integer</type>
      </arg>
      <doc>Returns the held object at the given index.</doc>
    </method>
    <method>
      <name>getWornAt</name>
      <invoke>get_worn_at</invoke>
      <return>
        <type>Object</type>
      </return>
      <arg>
        <name>index</name>
        <type>Integer</type>
      </arg>
      <doc>Returns the worn object at the given index.</doc>
    </method>
    <method>
      <name>getEquipAt</name>
      <invoke>get_equip_at</invoke>
      <return>
        <type>Object</type>
      </return>
      <arg>
        <name>index</name>
        <type>Integer</type>
      </arg>
      <doc>Returns the equipped object at the given index.</doc>
    </method>
    <method>
      <name>hold</name>
      <invoke>hold</invoke>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>object</name>
        <type>Object</type>
      </arg>
      <doc>This will make the creature hold the given object.  If the creature cannot hold the object (i.e., their hands are full), the method will _return = -1.  Otherwise, the body location ID will be returned.</doc>
    </method>
    <method>
      <name>wear</name>
      <invoke>wear</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <arg>
        <name>object</name>
        <type>Object</type>
      </arg>
      <doc>This will make the creature wear the given object.  If the creature cannot wear the object (i.e., no suitable body location is free), the method will _return = -1.  Otherwise, the body location ID will be returned.</doc>
    </method>
    <method>
      <name>equip</name>
      <invoke>equip</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <arg>
        <name>object</name>
        <type>Object</type>
      </arg>
      <doc>This method is identical to the wear method, except that if no available body location for wearing the object can be found, the creature will try to hold the object instead.  If no suitable body locations are found, and the creature's hands are full, the method returns -1.  Otherwise, the body location ID will be returned.</doc>
    </method>

    <!-- ObjectUsages -->
    <method>
      <name>doGo</name>
      <invoke>do_go</invoke>
      <arg>
        <name>portal</name>
        <type>Portal</type>
        <doc>Portal to use.</doc>
      </arg>
      <doc>The creature will attempt to use the given portal.</doc>
    </method>
    <method>
      <name>attack</name>
      <arg>
        <name>victim</name>
        <type>Creature</type>
        <doc>Creature to attack.</doc>
      </arg>
      <doc>This action causes an attack to be made.  Creatures must have a weapon to attack.</doc>
      <code><![CDATA[_self->do_attack(_arg_victim);]]></code>
    </method>

    <!-- coins -->
    <method>
      <name>getCoins</name>
      <invoke>get_coins</invoke>
      <return>
        <type>Integer</type>
        <doc>Coins in inventory.</doc>
      </return>
    </method>
    <method>
      <name>takeCoins</name>
      <invoke>take_coins</invoke>
      <arg>
        <name>amount</name>
        <type>Integer</type>
        <doc>Number of coins to take.</doc>
      </arg>
      <return>
        <type>Integer</type>
        <doc>Number of coins left.</doc>
      </return>
      <doc>Takes a number of coins from the creature.  If there aren't that many coins left, the creature is left with 0 coins.  When doing transactions of coins, you should be careful that you don't assume the creature has more coins than they really do.</doc>
    </method>
    <method>
      <name>giveCoins</name>
      <invoke>give_coins</invoke>
      <arg>
        <name>amount</name>
        <type>Integer</type>
        <doc>Number of coins to give.</doc>
      </arg>
      <return>
        <type>Integer</type>
        <doc>Number of coins the creature now has.</doc>
      </return>
      <doc>Gives a number of coins to the creature.  Creatures have a limit on how many coins they can carry.  You must be very careful during transactions and check the return value of this method; if the creature has less coins than you anticipated after the method, they can't carry any more coins.  You should return the left over to the source they came from.</doc>
    </method>

    <!-- Searching -->
    <method>
      <name>clFindObject</name>
      <invoke>cl_find_object</invoke>
      <return>
        <type>Object</type>
        <doc>The found object, or nil if not found.</doc>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
        <doc>Name of object to look for.  Can include flavour text and numeric indexes.</doc>
      </arg>
      <arg>
        <name>location</name>
        <type>Integer</type>
        <doc>Any of the GOC_* values.</doc>
      </arg>
      <arg>
        <name>silent</name>
        <type>Boolean</type>
        <doc>Set to true if not "cannot find" message should be printed to the player.</doc>
      </arg>
      <doc>Search the creature's room (or inventory) for the named object.  The name should generally be player input.  This call can resolve arbitrary names, like "the sword" or "my other pouch."</doc>
    </method>
    <method>
      <name>clFindCreature</name>
      <invoke>cl_find_creature</invoke>
      <return>
        <type>Creature</type>
        <doc>The found player or <link type="NPC"/>, or nil if not found.</doc>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
        <doc>Name of creature to look for.  Can include flavour text and numeric indexes.</doc>
      </arg>
      <arg>
        <name>silent</name>
        <type>Boolean</type>
        <doc>Set to true if not "cannot find" message should be printed to the player.</doc>
      </arg>
      <doc>This function searched for the named creature (<link type="NPC"/> or <link type="Player"/>) in the current room.  The function can handle arbitrary names, like "the wolf" or "second thug."</doc>
    </method>
    <method>
      <name>clFindPortal</name>
      <invoke>cl_find_portal</invoke>
      <return>
        <type>Portal</type>
        <doc>The found portal, or nil if not found.</doc>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
        <doc>Name of portal to look for.  Can include flavour text and numeric indexes.</doc>
      </arg>
      <arg>
        <name>silent</name>
        <type>Boolean</type>
        <doc>Set to true if not "cannot find" message should be printed to the player.</doc>
      </arg>
      <doc>Searches the room for the named portal.</doc>
    </method>
    <method>
      <name>clFindAny</name>
      <invoke>cl_find_any</invoke>
      <return>
        <type>Entity</type>
        <doc>The found <link type="Object"/>, <link type="Creature"/>, or Portal, or nil if not found.</doc>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
        <doc>Name of entity to look for.  Can include flavour text and numeric indexes.</doc>
      </arg>
      <arg>
        <name>silent</name>
        <type>Boolean</type>
        <doc>Set to true if not "cannot find" message should be printed to the player.</doc>
      </arg>
    </method>

    <!-- ObjectUsages -->
    <method>
      <name>say</name>
      <invoke>do_say</invoke>
      <arg>
        <name>text</name>
        <type>String</type>
      </arg>
      <doc>The creature will speak the given text.</doc>
    </method>

    <method>
      <name>exec</name>
      <invoke>process_command</invoke>
      <arg>
        <name>command</name>
        <type>String</type>
      </arg>
      <doc>The command will be interpreted as if player input.</doc>
    </method>

    <!-- IO stuff - should be in player only -->
    <method>
      <name>put</name>
      <arg>
        <name>text</name>
        <type>String</type>
      </arg>
      <doc>If the creature is a player, output the text to their connection; otherwise, do nothin.</doc>
      <code><![CDATA[*_self << _arg_text;]]></code>
    </method>
    <method>
      <name>print</name>
      <varg/>
      <code><![CDATA[
        for (size_t i = 1; i < _argc; ++ i) {
          Scriptix::Value val = _argv[i];
          if (val.is_int()) {
            *_self << Scriptix::Number::to_int(val);
          } else if (val.is_string()) {
            *_self << val.get_string();
          } else if (val.is_a(AweMUD_EntityType)) {
            Entity* entity = (Entity*)val.get();
            *_self << StreamName(entity);
          }
        }
      ]]></code>
      <doc>The same as put(), except it takes multiple arguments.  If an integer is given as an argument, it is converted to a string.  If an entity is given as an argument, its name will be output, colorized according to its entity type.</doc>
    </method>
    <method>
      <name>printf</name>
      <arg>
        <name>format</name>
        <type>String</type>
      </arg>
      <varg/>
      <code><![CDATA[
        if (_argc % 2 != 0) {
          Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Arguments to 'HTTP.displayTemplate()' must be in name/value pairs.");
          return Scriptix::Nil;
        }

        ParseArgs vlist;
        String name;
        for (size_t i = 2; i < _argc; i += 2) {
          name = _argv[1].get_string();
          if (_argv[i + 1].is_a(AweMUD_EntityType)) {
            vlist[name] = ((Entity*)_argv[i + 1].get());
          } else {
            _argv[i + 1] = _argv[i + 1].to_string();
            if (!_argv[i].is_nil())
              vlist[name] = _argv[i + 1].get_string();
          }
        }

        parse::text(*_self, _arg_format, vlist);
      ]]></code>
      <doc>This is a convenience function that calls <link function="strParse"/> on the arguments and <link method="Creature.put"/> on the result.  Additional arguments to the function are given as argument to the strParse call.  The first argument given to strParse is automatically the Creature instance itself.</doc>
    </method>
    <method>
      <name>rprint</name>
      <varg/>
      <code><![CDATA[
        if (_self->get_room()) {
          StreamControl stream(*_self->get_room());
          stream << StreamIgnore(_self);

          for (size_t i = 1; i < _argc; ++ i) {
            Scriptix::Value val = _argv[i];
            if (val.is_int()) {
              stream << Scriptix::Number::to_int(val);
            } else if (val.is_string()) {
              stream << val.get_string();
            } else if (val.is_a(AweMUD_EntityType)) {
              Entity* entity = (Entity*)val.get();
              stream << StreamName(entity);
            }
          }
        }
      ]]></code>
      <doc>Similar to print(), except output is sent to all players in the room of the creature, and not the creature itself.</doc>
    </method>
    <method>
      <name>riprint</name>
      <arg>
        <name>ignore</name>
        <type>Array</type>
        <doc>An array of <link type="Creature"/>s to ignore on output.</doc>
      </arg>
      <varg/>
      <code><![CDATA[
        if (_self->get_room()) {
          StreamControl stream(*_self->get_room());
          stream << StreamIgnore(_self);

          for (size_t i = 0; i < _arg_ignore->get_count(); ++i) {
            Scriptix::Value val = _arg_ignore->get_index(i);
            if (!val.is_a(AweMUD_CreatureType)) {
              Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Value in ignore list to Creature.riprint() is not a Creature");
              return Scriptix::Nil;
            }
            stream << StreamIgnore((Creature*)val.get());
          }

          for (size_t i = 1; i < _argc; ++ i) {
            Scriptix::Value val = _argv[i];
            if (val.is_int()) {
              stream << Scriptix::Number::to_int(val);
            } else if (val.is_int()) {
              stream << val.get_string();
            } else if (val.is_a(AweMUD_EntityType)) {
              Entity* entity = (Entity*)val.get();
              stream << StreamName(entity);
            }
          }
        }
      ]]></code>
      <doc>The same as rprint(), except output is not shown to any creatures in the ignore array.  The <link type="Creature"/> object the riprint method is called on is automatically added to the ignore list.</doc>
    </method>

    <!-- Status query -->
    <method>
      <name>canSee</name>
      <invoke>can_see</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Check if the creature can see.</doc>
    </method>
    <method>
      <name>canMove</name>
      <invoke>can_move</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Check if the creature can move.</doc>
    </method>
    <method>
      <name>canAct</name>
      <invoke>can_act</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Check if the creature can perform a complex action.</doc>
    </method>
    <method>
      <name>checkAlive</name>
      <invoke>check_alive</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Check if the creature is alive.  Prints an error message if the creature is dead.</doc>
    </method>
    <method>
      <name>checkMove</name>
      <invoke>check_move</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Check if the creature can move.  Prints an error message if the creature cannot move.</doc>
    </method>
    <method>
      <name>checkRt</name>
      <invoke>check_rt</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Check if the creature has any remaining roundtime.  Prints an error message if the creature must wait.</doc>
    </method>
    <method>
      <name>checkSee</name>
      <invoke>check_see</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <doc>check if the creature can see.  Prints an error message if the creature cannot see.</doc>
    </method>
    <method>
      <name>isDead</name>
      <invoke>is_dead</invoke>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Check if the creature is dead.</doc>
    </method>
    <method>
      <name>position</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>This is the creature's position.</doc>
      <code><![CDATA[_return =  _self->get_pos().get_value();]]></code>
    </method>
    <method>
      <name>setPosition</name>
      <arg>
        <name>position</name>
        <type>Integer</type>
        <doc>The creature's new position.</doc>
      </arg>
      <doc>Sets creature's position (sitting, standing, etc.).</doc>
      <code><![CDATA[
        _self->set_pos(CreaturePosition(_arg_position));
      ]]></code>
    </method>
    <method>
      <name>getGender</name>
      <cppname>get_gender</cppname>
      <return>
        <type>Integer</type>
      </return>
      <doc>The creature's gender.</doc>
      <code>_return = _self->get_gender().get_value();</code>
    </method>

    <!-- Round time -->
    <method>
      <name>getRoundTime</name>
      <invoke>get_round_time</invoke>
      <return>
        <type>Integer</type>
        <doc>Round time remaining for the current action list.</doc>
      </return>
    </method>

    <!-- Health/damage -->
    <method>
      <name>getHp</name>
      <invoke>get_hp</invoke>
      <return>
        <type>Integer</type>
      </return>
      <doc>The current hit-point total of the creature.</doc>
    </method>
    <method>
      <name>setHp</name>
      <invoke>set_hp</invoke>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>hp</name>
        <type>Integer</type>
      </arg>
      <doc>Sets the HP of the creature to the given amount.  This new value is not bounds checked (against max health), and will not trigger death or resurrection events.  This should only be used when absolutely necessary.</doc>
    </method>
    <method>
      <name>getMaxhp</name>
      <invoke>get_max_hp</invoke>
      <return>
        <type>Integer</type>
      </return>
      <doc>The maximum natural value of the creature's hit points.</doc>
    </method>
    <method>
      <name>damage</name>
      <invoke>damage</invoke>
      <arg>
        <name>amount</name>
        <type>Integer</type>
      </arg>
      <arg>
        <name>damager</name>
        <type>Creature</type>
        <nullok/>
      </arg>
      <doc>Subtracts the specified amount of damage from current HP.  Will trigger death if appropriate.  Also takes the entity that caused the damage, if appropriate.</doc>
    </method>
    <method>
      <name>heal</name>
      <invoke>heal</invoke>
      <arg>
        <name>amount</name>
        <type>Integer</type>
      </arg>
      <doc>Adds the specified amount of health.  Will trigger resurrection event if appropriate.</doc>
    </method>
    <method>
      <name>getHpPercent</name>
      <return>
        <type>Integer</type>
        <doc>Percent of remaining HP.</doc>
      </return>
      <doc>Returns a 0-100 percent indicating how much of the <link type="Creature"/>'s health is remaining.</doc>
      <code><![CDATA[
        if (_self->get_hp() <= 0 || _self->get_max_hp() <= 0)
          _return = 0;
        else
          _return = _self->get_hp() * 100 / _self->get_max_hp();
      ]]></code>
    </method>

    <!-- Room -->
    <method>
      <name>enter</name>
      <invoke>enter</invoke>
      <arg>
        <name>room</name>
        <type>Room</type>
      </arg>
      <arg>
        <name>portal</name>
        <type>Portal</type>
        <nullok/>
      </arg>
      <doc>Moves the creature to the specified room.  The portal they enter in from will be the given portal.</doc>
    </method>
    <method>
      <name>room</name>
      <invoke>get_room</invoke>
      <return>
        <type>Room</type>
      </return>
      <doc>The parent room.</doc>
    </method>

    <!-- Recalc -->
    <method>
      <name>recalcStats</name>
      <invoke>recalc_stats</invoke>
      <doc>Recalculate current stats.  Combines base stat with any active modifications.  (For example, <link type="PlayerRace"/> stat modifiers for the <link type="Player"/> sub-class.)</doc>
    </method>
    <method>
      <name>recalc</name>
      <invoke>recalc</invoke>
      <doc>Recalculates all sorts of various values.  This can be a rather intensive operation in many cases, and as such, has been split out into this call to large sets of changes faster; instead of recalculating these values after every modification, it is merely called when all modifications are complete.</doc>
    </method>
  </type>

  <!-- Player -->
  <type>
    <name>Player</name>
    <parent>Creature</parent>
    <doc>The <link type="Player"/> class represents a creature that is controlled by a human.  <link type="Player"/> classes also encompass the connection data.</doc>

    <!-- Experience -->
    <method>
      <name>grantExp</name>
      <invoke>grant_exp</invoke>
      <arg>
        <name>type</name>
        <type>Integer</type>
      </arg>
      <arg>
        <name>amount</name>
        <type>Integer</type>
      </arg>
      <doc>Grants specified amount of exp to the specified experience pool.</doc>
    </method>
    <method>
      <name>getExp</name>
      <invoke>get_exp</invoke>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>type</name>
        <type>Integer</type>
      </arg>
      <code><![CDATA[
        if (_arg_type >= 0 && _arg_type < NUM_EXPS) {
          _return = _self->get_exp (_arg_type);
        }
      ]]></code>
      <doc>Returns the available experience in the given pool.</doc>
    </method>

    <!-- Race -->
    <method>
      <name>getRace</name>
      <invoke>get_race</invoke>
      <return>
        <type>PlayerRace</type>
      </return>
      <doc>Get the race of the player.</doc>
    </method>
    <method>
      <name>setRace</name>
      <invoke>set_race</invoke>
      <return>
        <type>PlayerRace</type>
      </return>
      <arg>
        <name>race</name>
        <type>PlayerRace</type>
      </arg>
      <doc>Set the race of the player.  This does not apply any racial modifiers.</doc>
    </method>

    <!-- Birthday/age -->
    <method>
      <name>getBirthday</name>
      <return>
        <type>Time</type>
      </return>
      <doc>Returns the birthday of the player.  The returned object is a copy of the data stored in the player.  Modifying the returned object will not alter the birthday of the player.  Altered birthday objects must be passed back to set_birthday() to take effect.</doc>
      <code><![CDATA[
        _return = new Time(AweMUD_TimeType, _self->get_birthday());
      ]]></code>
    </method>
    <method>
      <name>setBirthday</name>
      <arg>
        <name>time</name>
        <type>Time</type>
      </arg>
      <doc>Sets the birthday of the player to the value of the given Time object.</doc>
      <code><![CDATA[
        _self->set_birthday(_arg_time->data());
      ]]></code>
    </method>
    <method>
      <name>getAge</name>
      <invoke>get_age</invoke>
      <return>
        <type>Integer</type>
      </return>
      <doc>Returns the age of the creature in years.</doc>
    </method>

    <!-- Description details -->
    <method>
      <name>getTrait</name>
      <arg>
        <name>trait</name>
        <type>String</type>
        <doc>Trait value to retrieve.</doc>
      </arg>
      <return>
        <type>String</type>
        <doc>The trait's description, normally processed with the text parsing engine before displaying.</doc>
      </return>
      <code><![CDATA[_return = _self->get_trait(CreatureTraitID::lookup(_arg_trait)).get_desc();]]></code>
    </method>
    <method>
      <name>setTrait</name>
      <arg>
        <name>trait</name>
        <type>String</type>
        <doc>Trait value to set.</doc>
      </arg>
      <arg>
        <name>value</name>
        <type>String</type>
        <doc>Name of a specific trait value to set the trait to.</doc>
      </arg>
      <code><![CDATA[_self->set_trait(CreatureTraitID::lookup(_arg_trait), CreatureTraitValue::lookup(_arg_value));]]></code>
    </method>
    <method>
      <name>hisHer</name>
      <invoke>his_her</invoke>
      <return>
        <type>String</type>
        <doc>"his", "her", or "its", depending on gender.</doc>
      </return>
      <code/>
      <doc>Note how the feminine result of this method is "her".  In cases where "hers" would be appropriate, use <link method="Player.hisHers"/>.</doc>
    </method>
    <method>
      <name>hisHers</name>
      <invoke>his_hers</invoke>
      <return>
        <type>String</type>
        <doc>"his", "hers", or "its", depending on gender.</doc>
      </return>
      <code/>
      <doc>Note how the feminine result of this method is "hers".  In cases where "her" would be appropriate, use <link method="Player.hisHer"/>.</doc>
    </method>
    <method>
      <name>getHeight</name>
      <invoke>get_height</invoke>
      <return>
        <type>Integer</type>
        <doc>Player height.  Default is in inches, game designers may choose to use centimeters.</doc>
      </return>
    </method>
    <method>
      <name>setHeight</name>
      <invoke>set_height</invoke>
      <arg>
        <name>height</name>
        <type>Integer</type>
        <doc>New player height.  Default is in inches, game designers may choose to use centimeters.  Should not be higher than 255.</doc>
      </arg>
    </method>

    <!-- Processors/IO -->
    <method>
      <name>clearScr</name>
      <invoke>clear_scr</invoke>
      <doc>Clear the player's screen.</doc>
    </method>
    <method>
      <name>setIndent</name>
      <invoke>set_indent</invoke>
      <arg>
        <name>amount</name>
        <type>Integer</type>
        <doc>Amount to indent all further output by.</doc>
      </arg>
    </method>

    <!-- Weird information functions -->
    <method>
      <name>showClasses</name>
      <doc>Displays the player's classes to the player.</doc>
      <code/>
    </method>
    <method>
      <name>showExp</name>
      <doc>Displays the player's experience chart to the player.</doc>
      <code/>
    </method>
    <method>
      <name>showStats</name>
      <doc>Displays the player's statistics to the player.</doc>
      <code/>
    </method>
    <method>
      <name>showInfo</name>
      <doc>Displays the player's attributes to the player.</doc>
      <code/>
    </method>

    <!-- Recalculation -->
    <method>
      <name>recalcHealth</name>
      <invoke>recalc_health</invoke>
      <doc>Recalculates base health for the player.</doc>
    </method>

    <!-- Misc edititing -->
    <method>
      <name>setBaseStat</name>
      <arg>
        <name>stat</name>
        <type>Integer</type>
      </arg>
      <arg>
        <name>value</name>
        <type>Integer</type>
      </arg>
      <doc>Set the base value of the specified stat.</doc>
      <code><![CDATA[
        if (_arg_stat >= 0 && _arg_stat < CreatureStatID::COUNT)
          _self->set_base_stat(_arg_stat, _arg_value);
      ]]></code>
    </method>
    <method>
      <name>adjustAlignment</name>
      <invoke>adjust_alignment</invoke>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>adjustment</name>
        <type>Integer</type>
      </arg>
      <doc>Modified the alignment by the given amount, and return the result.</doc>
    </method>
    <method>
      <name>setAlignment</name>
      <invoke>set_alignment</invoke>
      <arg>
        <name>value</name>
        <type>Integer</type>
      </arg>
      <doc>Set the creature's alignment to the given value.</doc>
    </method>
    <method>
      <name>setGender</name>
      <invoke>set_gender</invoke>
      <cppname>set_gender</cppname>
      <arg>
        <name>gender</name>
        <type>Integer</type>
      </arg>
      <doc>The creature's gender.</doc>
    </method>

    <!-- Permissions -->
    <method>
      <name>hasAccess</name>
      <arg>
        <name>privilege</name>
        <type>String</type>
        <doc>The privilege to check for.</doc>
      </arg>
      <return>
        <type>Boolean</type>
        <doc>True if the player has the privilege, false if she does not.</doc>
      </return>
      <code><![CDATA[_return = _self->get_account()->has_access(AccessID::lookup(_arg_privilege));]]></code>
    </method>
    <!-- NOTE: do not offer access changing methods, those are for admins only -->
  </type>
  <!-- Player functions -->
  <function>
    <name>getPlayer</name>
    <return>
      <type>Player</type>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
    </arg>
    <code>_return = PlayerManager.get(_arg_name);</code>
    <doc>Find the player with the given name.</doc>
  </function>

  <!-- NPC -->
  <type>
    <name>NPC</name>
    <parent>Creature</parent>
    <cppname>Npc</cppname>

    <doc>Defines a non-player creature, such as monsters.</doc>

    <!-- Blueprints -->
    <method>
      <name>isBlueprint</name>
      <invoke>is_blueprint</invoke>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of a blueprint.</doc>
      </arg>
      <return>
        <type>Boolean</type>
        <doc>True if the NPC descends from the named blueprint, or false if not.</doc>
      </return>
      <doc>Use this method to determine if the NPC descends from a given blueprint.  You might use this, for example, to see if the NPC is a 'bank_note' blueprint, or one of its derivatives.</doc>
    </method>
    <method>
      <name>getBlueprint</name>
      <invoke>get_blueprint</invoke>
      <return>
        <type>NPCBlueprint</type>
        <doc>The NPC's blueprint.</doc>
      </return>
    </method>

    <!-- utility -->
    <method>
      <name>isZoneLocked</name>
      <invoke>is_zone_locked</invoke>
      <return>
        <type>Boolean</type>
        <doc><link global="true">True</link> if the NPC is not allowed to leave the zone.</doc>
      </return>
    </method>
    <method>
      <name>canUsePortal</name>
      <invoke>can_use_portal</invoke>
      <arg>
        <name>portal</name>
        <type>Portal</type>
      </arg>
      <return>
        <type>Boolean</type>
        <doc>Returns <link global="true"/> if the portal is usable by the NPC, or <link global="false"/> otherwise.</doc>
      </return>
    </method>
    <method>
      <name>goRandomPortal</name>
      <invoke>go_random_portal</invoke>
      <return>
        <type>Boolean</type>
        <doc>Returns <link global="false"/> if no portal could be followed, otherwise <link global="true"/>.</doc>
      </return>
      <code/>
    </method>

    <method>
      <name>pumpAI</name>
      <invoke>pump</invoke>
      <arg>
        <name>data</name>
        <type>Mixed</type>
        <doc>Data to be passed to the AI's pump handler.</doc>
      </arg>
      <doc>This is a generic signaling mechanism for the AI.  The AI may have a pump handler installed with does just about anything, and the data argument can be used for whatever purpose is necessary.</doc>
    </method>
    <method>
      <name>state</name>
      <code/>
      <arg>
        <name>state</name>
        <type>String</type>
        <doc>State to switch to.</doc>
      </arg>>
      <doc>This method sets the self->ai_state member to the value of the state argument, and then calls self->pump_ai('state');</doc>
    </method>
  </type>
  <function>
    <name>createNpcFromBlueprint</name>
    <return>
      <type>NPC</type>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
    </arg>
    <doc>Loads an <link type="NPC"/> from the given blueprint name.  Returns nil if there is no such blueprint.</doc>
    <code><![CDATA[
      _return = Npc::load_blueprint(_arg_name);
    ]]></code>
  </function>

  <type>
    <name>NPCBlueprint</name>
    <cppname>NpcBlueprint</cppname>
    <doc>NPC Blueprints describe an <link type="NPC"/>'s information.  Any NPC can derive from one a blueprint, inheriting that's blueprint's information.</doc>

    <!-- basics -->
    <method>
      <name>getId</name>
      <invoke>get_id</invoke>
      <return>
        <type>String</type>
        <doc>The blueprint's unique ID.</doc>
      </return>
    </method>
    <method>
      <name>getParent</name>
      <invoke>get_parent</invoke>
      <return>
        <type>NpcBlueprint</type>
        <doc>The blueprint this blueprint derives from, or nil if there is no parent.</doc>
      </return>
      <doc>Blueprints can derive from other blueprints, forming an inheritance.  Modifications to a parent blueprint affect all child blueprints, and any entity that derives from the blueprint or its children.</doc>
    </method>
    <method>
      <name>getName</name>
      <return>
        <type>String</type>
        <doc>The blueprint's name, without the article.</doc>
      </return>
      <code><![CDATA[_return = _self->get_name().get_text();]]></code>
    </method>
    <method>
      <name>getFullName</name>
      <return>
        <type>String</type>
        <doc>The blueprint's name, with the article.</doc>
      </return>
      <code><![CDATA[_return = _self->get_name().get_name();]]></code>
    </method>

    <!-- create -->
    <method>
      <name>create</name>
      <return>
        <type>NPC</type>
        <doc>A new NPC derived from the blueprint.</doc>
      </return>
      <doc>This function creates a new NPC instance, which is derived from the blueprint.</doc>
      <code>_return = new Npc(_self);</code>
    </method>
  </type>
  <function>
    <name>getNpcBlueprint</name>
    <return>
      <type>NPCBlueprint</type>
      <doc>Blueprint with the given ID, or nil if the blueprint does not exist.</doc>
    </return>
    <arg>
      <type>String</type>
      <name>id</name>
      <doc>ID of blueprint to lookup.</doc>
    </arg>
    <code><![CDATA[_return = NpcBlueprintManager.lookup(_arg_id);]]></code>
  </function>

  <!-- Object -->
  <type>
    <name>Object</name>
    <parent>Entity</parent>
    <doc><link type="Object"/>s are the physical items that exist in the world.  <link type="Object"/>s can be anything from forks to statues, from magic wands to mundane vases, or from deadly weapons to protective armour.</doc>

    <!-- Change object's name -->
    <method>
      <name>setBaseName</name>
      <arg>
        <name>name</name>
        <type>String</type>
        <doc>A base name, including the correct article.</doc>
      </arg>
      <invoke>set_name</invoke>
      <doc>The base name of an entity includes an article.  For example, "a longsword," "the Mjolnir," "an hourglass," and "some britches."  If a name with no article is passed to this function, the function will make some probably inaccurate guesses as to what the correct article should be.</doc>
    </method>

    <!-- Misc -->
    <method>
      <name>isBlueprint</name>
      <invoke>is_blueprint</invoke>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of a blueprint.</doc>
      </arg>
      <return>
        <type>Boolean</type>
        <doc>True if the object descends from the named blueprint, or false if not.</doc>
      </return>
      <doc>Use this method to determine if the object descends from a given blueprint.  You might use this, for example, to see if the object is a 'bank_note' blueprint, or one of its derivatives.</doc>
    </method>

    <!-- Weight -->
    <method>
      <name>getWeight</name>
      <invoke>get_weight</invoke>
      <return>
        <type>Integer</type>
      </return>
      <doc>Returns the calculated weight of an object.  This includes weight from items inside/on the object (in the case of a container).</doc>
    </method>
    <method>
      <name>getRealWeight</name>
      <invoke>get_real_weight</invoke>
      <return>
        <type>Integer</type>
      </return>
      <doc>Returns the actual weight of an object, without the additional calculations factored in.</doc>
    </method>

    <!-- Cost -->
    <method>
      <name>getCost</name>
      <invoke>get_cost</invoke>
      <return>
        <type>Integer</type>
      </return>
      <doc>Returns the cost of an object.</doc>
    </method>

    <!-- Containers -->
    <method>
      <name>findObject</name>
      <invoke>find_object</invoke>
      <return>
        <type>Object</type>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
      </arg>
      <arg>
        <name>index</name>
        <type>Integer</type>
      </arg>
      <arg>
        <name>type</name>
        <type>Integer</type>
      </arg>
      <doc>This will search the container of the given type (or all container types if type=0) and _return = the Nth match against the given name, where N is the given index, starting at 1.</doc>
      <code><![CDATA[_self->find_object(_arg_name, _arg_index, ObjectLocation(_arg_type));]]></code>
    </method>
    <method>
      <name>addObject</name>
      <invoke>add_object</invoke>
      <arg>
        <name>object</name>
        <type>Object</type>
      </arg>
      <arg>
        <name>type</name>
        <type>Integer</type>
      </arg>
      <doc>Adds the given object to the container of the given type.</doc>
      <code><![CDATA[_self->add_object(_arg_object, ObjectLocation(_arg_type));]]></code>
    </method>

    <!-- Parent tracking -->
    <method>
      <name>room</name>
      <invoke>get_room</invoke>
      <return>
        <type>Room</type>
        <doc><link type="Room"/> the object is in, or nil</doc>
      </return>
      <doc>Returns the room the object is in.  This will track up the parent list, so that (for example) on object in a container equipped on a creature will return the room the creature is in.</doc>
    </method>
    <method>
      <name>getHolder</name>
      <invoke>get_holder</invoke>
      <return>
        <type>Creature</type>
        <doc>Creature carrying the object, or nil.</doc>
      </return>
      <doc>If the object is being carried by a Creature, return that creature.</doc>
    </method>

    <!-- flags -->
    <method>
      <name>isHidden</name>
      <invoke>is_hidden</invoke>
      <return>
        <type>Boolean</type>
        <doc>True if the object is hidden from the room/container list, false otherwise.</doc>
      </return>
    </method>
    <method>
      <name>isTouchable</name>
      <invoke>is_touchable</invoke>
      <return>
        <type>Boolean</type>
        <doc>True if the object may be physically touched, false otherwise.</doc>
      </return>
    </method>
    <method>
      <name>isGettable</name>
      <invoke>is_gettable</invoke>
      <return>
        <type>Boolean</type>
        <doc>True if the object may be picked up, false otherwise.</doc>
      </return>
    </method>
    <method>
      <name>isDropable</name>
      <invoke>is_dropable</invoke>
      <return>
        <type>Boolean</type>
        <doc>True if the object may be dropped, false otherwise.</doc>
      </return>
    </method>
  </type>
  <function>
    <name>createObjectFromBlueprint</name>
    <return>
      <type>Object</type>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
    </arg>
    <doc>Loads an object from the given blueprint name.  Returns nil if there is no such name.</doc>
    <code><![CDATA[
      _return = Object::load_blueprint(_arg_name);
    ]]></code>
  </function>

  <type>
    <name>ObjectBlueprint</name>
    <doc>Object Blueprints describe an <link type="Object"/>'s information.  Any object can derive from one a blueprint, inheriting that's blueprint's information.</doc>

    <!-- basics -->
    <method>
      <name>getId</name>
      <return>
        <type>String</type>
        <doc>The blueprint's unique ID.</doc>
      </return>
      <invoke>get_id</invoke>
    </method>
    <method>
      <name>getParent</name>
      <return>
        <type>ObjectBlueprint</type>
        <doc>The blueprint this blueprint derives from, or nil if there is no parent.</doc>
      </return>
      <doc>Blueprints can derive from other blueprints, forming an inheritance.  Modifications to a parent blueprint affect all child blueprints, and any entity that derives from the blueprint or its children.</doc>
      <invoke>get_parent</invoke>
    </method>
    <method>
      <name>getName</name>
      <return>
        <type>String</type>
        <doc>The blueprint's name, without the article.</doc>
      </return>
      <code><![CDATA[_return = _self->get_name().get_text();]]></code>
    </method>
    <method>
      <name>getFullName</name>
      <return>
        <type>String</type>
        <doc>The blueprint's name, with the article.</doc>
      </return>
      <code><![CDATA[_return = _self->get_name().get_name();]]></code>
    </method>
    <method>
      <name>getCost</name>
      <return>
        <type>Integer</type>
        <doc>Base cost of objects deriving from the blueprint.</doc>
      </return>
      <invoke>get_cost</invoke>
    </method>

    <!-- create -->
    <method>
      <name>create</name>
      <return>
        <type>Object</type>
        <doc>A new Object derived from the blueprint.</doc>
      </return>
      <doc>This function creates a new Object instance, which is derived from the blueprint.</doc>
      <code>_return = new Object(_self);</code>
    </method>
  </type>
  <function>
    <name>getObjectBlueprint</name>
    <arg>
      <type>String</type>
      <name>name</name>
      <doc>Name of the blueprint to lookup.</doc>
    </arg>
    <return>
      <type>ObjectBlueprint</type>
      <doc>The named blueprint, or nil if it doesn't exist.</doc>
    </return>
    <doc>Looks up the named <link type="Object"/> blueprint in the blueprint database.  If the blueprint doesn't exist, nil is returned.</doc>
    <code>_return = ObjectBlueprintManager.lookup(_arg_name);</code>
  </function>

  <!-- Room -->
  <type>
    <name>Room</name>
    <parent>Entity</parent>
    <doc>A room is the fundamental building block of the MUD world.</doc>

    <method>
      <name>setName</name>
      <arg>
        <name>name</name>
        <type>String</type>
        <doc>New entity name.</doc>
      </arg>
      <invoke>set_name</invoke>
    </method>
    <method>
      <name>setDesc</name>
      <arg>
        <name>desc</name>
        <type>String</type>
        <doc>New entity description.</doc>
      </arg>
      <invoke>set_desc</invoke>
    </method>

    <!-- Creature management -->
    <method>
      <name>findCreature</name>
      <return>
        <type>Creature</type>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
      </arg>
      <doc>Locate a creature, searching for a match against name.</doc>
      <invoke>find_creature</invoke>
    </method>
    <method>
      <name>creatures</name>
      <return>
        <type>Iterator</type>
      </return>
      <iterdata>
        size_t index;
        Room* room;
      </iterdata>
      <iternext><![CDATA[
        if (index < room->creatures.size()) {
          _iterval = room->creatures[index];
          ++index;
          return true;
        } else {
          _iterval = Scriptix::Nil;
          return false;
        }
      ]]></iternext>
      <code>_return = new _iterator(); _return->index = 0; _return->room = _self;</code>
      <doc>Returns an iterator for all the creatures in the room.</doc>
    </method>
    <method>
      <name>addCreature</name>
      <arg>
        <name>object</name>
        <type>Creature</type>
      </arg>
      <doc>Adds the given creature to the room's floor.</doc>
      <invoke>add_creature</invoke>
    </method>

    <!-- Object management -->
    <method>
      <name>findObject</name>
      <return>
        <type>Object</type>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
      </arg>
      <doc>Locate an object, searching for a match against name.</doc>
      <invoke>find_object</invoke>
    </method>
    <method>
      <name>objects</name>
      <return>
        <type>Iterator</type>
      </return>
      <iterdata>
        size_t index;
        Room* room;
      </iterdata>
      <iternext><![CDATA[
        if (index < room->objects.size()) {
          _iterval = room->objects[index];
          ++index;
          return true;
        } else {
          _iterval = Scriptix::Nil;
          return false;
        }
      ]]></iternext>
      <code>_return = new _iterator(); _return->index = 0; _return->room = _self;</code>
      <doc>Returns an iterator for all the objects in the room.</doc>
    </method>
    <method>
      <name>addObject</name>
      <arg>
        <name>object</name>
        <type>Object</type>
      </arg>
      <doc>Adds the given object to the room's floor.</doc>
      <invoke>add_object</invoke>
    </method>

    <!-- portals -->
    <method>
      <name>findPortal</name>
      <return>
        <type>Portal</type>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
      </arg>
      <doc>Locate an portal, searching for a match against name.</doc>
      <invoke>find_portal</invoke>
    </method>
    <method>
      <name>portals</name>
      <return>
        <type>Iterator</type>
      </return>
      <iterdata>
        size_t index;
        Room* room;
      </iterdata>
      <iternext><![CDATA[
        if (index < room->portals.size()) {
          _iterval = room->portals[index];
          ++index;
          return true;
        } else {
          _iterval = Scriptix::Nil;
          return false;
        }
      ]]></iternext>
      <code>_return = new _iterator(); _return->index = 0; _return->room = _self;</code>
      <doc>Returns an iterator for all the portals in the room.</doc>
    </method>

    <!-- Output a message -->
    <method>
      <name>put</name>
      <arg>
        <name>text</name>
        <type>String</type>
      </arg>
      <code><![CDATA[_self->put(_arg_text, _arg_text.size());]]></code>
      <doc>Sends the text to all creatures in the room.</doc>
      <invoke>put</invoke>
    </method>
    <method>
      <name>print</name>
      <varg/>
      <code><![CDATA[
        Scriptix::Value val;
        StreamControl stream(*_self);
        for (size_t i = 1; i < _argc; ++ i) {
          val = _argv[i];
          if (val.is_int()) {
            stream << Scriptix::Number::to_int(val);
          } else if (val.is_int()) {
            stream << val.get_string();
          } else if (val.is_a(AweMUD_EntityType)) {
            Entity* entity = (Entity*)val.get();
            stream << StreamName(entity);
          }
        }
      ]]></code>
      <doc>The same as put(), except it takes multiple arguments.  If an integer is given as an argument, it is converted to a string.  If an entity is given as an argument, its name will be output, colorized according to its entity type.</doc>
    </method>
    <method>
      <name>printf</name>
      <arg>
        <name>format</name>
        <type>String</type>
      </arg>
      <varg/>
      <code><![CDATA[
        if (_argc % 2 != 0) {
          Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Arguments to 'HTTP.displayTemplate()' must be in name/value pairs.");
          return Scriptix::Nil;
        }

        ParseArgs vlist;
        String name;
        for (size_t i = 2; i < _argc; i += 2) {
          name = _argv[1].get_string();
          if (_argv[i + 1].is_a(AweMUD_EntityType)) {
            vlist[name] = ((Entity*)_argv[i + 1].get());
          } else {
            _argv[i + 1] = _argv[i + 1].to_string();
            if (!_argv[i].is_nil())
              vlist[name] = _argv[i + 1].get_string();
          }
        }

        parse::text(*_self, _arg_format, vlist);
      ]]></code>
      <doc>This is a convenience function that calls <link function="strParse"/> on the arguments and <link method="Room.put"/> on the result.  Additional arguments to the function are given as argument to the strParse call.  The first argument given to strParse is automatically the Room instance itself.</doc>
    </method>

    <!-- Basics -->
    <method>
      <name>zone</name>
      <return>
        <type>Zone</type>
      </return>
      <doc>Returns the parent zone.</doc>
      <invoke>get_zone</invoke>
    </method>
    <method>
      <name>getId</name>
      <return>
        <type>String</type>
      </return>
      <doc>Returns the unique ID of the room.</doc>
      <invoke>get_id</invoke>
    </method>

    <!-- flags -->
    <method>
      <name>isOutdoors</name>
      <return>
        <type>Boolean</type>
        <doc>True if the room is outdoors, false if it's indoors.</doc>
      </return>
      <invoke>is_outdoors</invoke>
    </method>
    <method>
      <name>isSafe</name>
      <return>
        <type>Boolean</type>
        <doc>True if the room is combat-free, false otherwise.</doc>
      </return>
      <invoke>is_safe</invoke>
    </method>
    <method>
      <name>isNoweather</name>
      <return>
        <type>Boolean</type>
        <doc>True if the room is should not display weather in its description, false otherwise.</doc>
      </return>
      <invoke>is_noweather</invoke>
    </method>
    <method>
      <name>setOutdoors</name>
      <arg>
        <name>value</name>
        <type>Boolean</type>
        <doc>True if the room is outdoors, false if it's indoors.</doc>
      </arg>
      <invoke>set_outdoors</invoke>
    </method>
    <method>
      <name>setSafe</name>
      <arg>
        <name>value</name>
        <type>Boolean</type>
        <doc>True if the room is combat-free, false otherwise.</doc>
      </arg>
      <invoke>set_safe</invoke>
    </method>
    <method>
      <name>setNoweather</name>
      <arg>
        <name>value</name>
        <type>Boolean</type>
        <doc>True if the room is should not display weather in its description, false otherwise.</doc>
      </arg>
      <invoke>set_noweather</invoke>
    </method>
  </type>
  <function>
    <name>getRoom</name>
    <return>
      <type>Room</type>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
    </arg>
    <code>return ZoneManager.get_room(_arg_name);</code>
    <doc>Find and return the specified room if it exists.</doc>
  </function>

  <!-- Room Portal -->
  <type>
    <name>Portal</name>
    <parent>Entity</parent>
    <doc><link type="Portal"/>'s represent all of the various kinds of portals that may exist in a room.</doc>

    <method>
      <name>setName</name>
      <arg>
        <name>name</name>
        <type>String</type>
        <doc>New entity name.</doc>
      </arg>
      <invoke>set_name</invoke>
    </method>
    <method>
      <name>setDesc</name>
      <arg>
        <name>desc</name>
        <type>String</type>
        <doc>New entity description.</doc>
      </arg>
      <invoke>set_desc</invoke>
    </method>

    <!-- usage info -->
    <method>
      <name>getUsage</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>The usage parameter specifies how the exist is used.  These include things such as climable, crawlable, and so on.</doc>
      <code><![CDATA[_return = _self->get_usage().get_value();]]></code>
    </method>
    <method>
      <name>getDetail</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>The detail parameter specifies what flavour text is added to the portal's usage.  For example, a climbable portal may be "climb up" or "climb down" or "climb through" or so on.</doc>
      <code><![CDATA[_return = _self->get_usage().get_value();]]></code>
    </method>
    <method>
      <name>getDir</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>Returns the direction the portal heads in, such as north or southeast.</doc>
      <code><![CDATA[_return = _self->get_dir().get_value();]]></code>
    </method>

    <!-- states -->
    <method>
      <name>open</name>
      <arg>
        <type>Room</type>
        <name>base</name>
        <doc>The Room from which the portal was opened.</doc>
      </arg>
      <arg>
        <type>Creature</type>
        <name>actor</name>
        <doc>The Creature who performed the action, if any.</doc>
      </arg>
      <doc>Opens the portal.</doc>
    </method>
    <method>
      <name>close</name>
      <arg>
        <type>Room</type>
        <name>base</name>
        <doc>The Room from which the portal was closed.</doc>
      </arg>
      <arg>
        <type>Creature</type>
        <name>actor</name>
        <doc>The Creature who performed the action, if any.</doc>
      </arg>
      <doc>Closes the portal.</doc>
    </method>
    <method>
      <name>isClosed</name>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Return true if the portal is closed.</doc>
      <invoke>is_closed</invoke>
    </method>
    <method>
      <name>isLocked</name>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Return true if the portal is locked.</doc>
      <invoke>is_locked</invoke>
    </method>
    <method>
      <name>isHidden</name>
      <return>
        <type>Boolean</type>
      </return>
      <doc>Return true if the portal is hidden.</doc>
      <invoke>is_hidden</invoke>
    </method>
    <method>
      <name>isStandard</name>
      <return>
        <type>Boolean</type>
        <doc><link global="true">True</link> if the portal has a standard name, and <link global="false">false</link> otherwise.</doc>
      </return>
      <doc>Standard portals are exists which have no custom name.  That is, their name is the same as their direction.  These are usually portals such as "north" and "southeast."</doc>
      <invoke>is_standard</invoke>
    </method>
    <method>
      <name>isNolook</name>
      <return>
        <type>Boolean</type>
        <doc><link global="true">True</link> if the portal cannot be looked through.</doc>
      </return>
      <doc>Normally, when an portal is looked at, the <link type="Room">room</link> the portal leads to can be seen.  When the nolook flag is enabled, however, the room is not displayed.</doc>
      <invoke>is_nolook</invoke>
    </method>
    <method>
      <name>isDisabled</name>
      <return>
        <type>Boolean</type>
        <doc><link global="true">True</link> if the portal is disabled and unusable.</doc>
      </return>
      <doc>Disabled portals cannot be used.  Additionally, they are automatically hidden.  Note that the <link method="Portal.isHidden">is_hidden()</link> method will not reflect this fact, as it only checks if the hidden flag is explicitly set.</doc>
      <invoke>is_disabled</invoke>
    </method>
    <method>
      <name>setDisabled</name>
      <arg>
        <name>state</name>
        <type>Boolean</type>
        <doc><link global="true">True</link> if the portal should be disabled, <link global="false">false</link> if it should be enabled as normal.</doc>
      </arg>
      <invoke>set_disabled</invoke>
    </method>
  </type>

  <!-- Zone class -->
  <type>
    <name>Zone</name>
    <parent>Entity</parent>
    <doc><link type="Zone"/>s are sub-parts of the world which hold rooms.  <link type="Zone"/>s are best thought of as logical, large-scale areas.</doc>

    <!-- Basics -->
    <method>
      <name>getId</name>
      <return>
        <type>String</type>
      </return>
      <doc>Returns the unique ID of the zone.</doc>
      <invoke>get_id</invoke>
    </method>

    <!-- Room functions -->
    <method>
      <name>getRoom</name>
      <return>
        <type>Room</type>
      </return>
      <arg>
        <name>name</name>
        <type>String</type>
      </arg>
      <doc>Retrieves the room with the given name, or nil if no such room exists.</doc>
      <invoke>get_room</invoke>
    </method>
    <method>
      <name>addRoom</name>
      <arg>
        <name>room</name>
        <type>Room</type>
      </arg>
      <doc>Adds the given room to the zone.</doc>
      <invoke>add_room</invoke>
    </method>
    <method>
      <name>rooms</name>
      <return>
        <type>Iterator</type>
      </return>
      <iterdata>size_t index; Zone* zone;</iterdata>
      <iternext>_iterval = zone->get_room_at(index++); return !_iterval.is_nil();</iternext>
      <code>_return = new _iterator(); _return->index= 0; _return->zone = _self;</code>
      <doc>Returns an iterator for all the rooms in the zone.</doc>
    </method>
  </type>
  <function>
    <name>getZone</name>
    <return>
      <type>Zone</type>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
    </arg>
    <code>ZoneManager.get_zone(_arg_name);</code>
    <doc>Retrieves the zone with the given name, or nil if no such zone exists.</doc>
  </function>
  <function>
    <name>createZone</name>
    <arg>
      <name>zone</name>
      <type>Zone</type>
    </arg>
    <code>ZoneManager.add_zone(_arg_zone);</code>
    <doc>Adds the given zone to the zone.</doc>
  </function>
  <function>
    <name>getZones</name>
    <return>
      <type>Iterator</type>
    </return>
    <iterdata>size_t index;</iterdata>
    <iternext>_iterval = ZoneManager.get_zone_at(index++); return !_iterval.is_nil();</iternext>
    <code>_return = new _iterator(); _return->index= 0;</code>
    <doc>Returns an iterator for all the zones.</doc>
  </function>

  <!-- Player Race class -->
  <type>
    <name>PlayerRace</name>
    <cppname>Race</cppname>
    <doc>The <link type="PlayerRace"/> class contains information on a playable race.</doc>

    <method>
      <name>getName</name>
      <return>
        <type>String</type>
      </return>
      <doc>The name of the player race.</doc>
      <invoke>get_name</invoke>
    </method>
    <method>
      <name>getLifeSpan</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>Returns the life span of the race in years.</doc>
      <invoke>get_life_span</invoke>
    </method>
    <method>
      <name>getStat</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>stat</name>
        <type>Integer</type>
      </arg>
      <doc>Fetches the state modifier of the given stat.</doc>
      <invoke>get_stat</invoke>
    </method>
    <method>
      <name>getAdjective</name>
      <return>
        <type>String</type>
      </return>
      <doc>Racial adjective (dwarven, elven, etc.).</doc>
      <invoke>get_adj</invoke>
    </method>
    <method>
      <name>getBody</name>
      <return>
        <type>String</type>
      </return>
      <doc>Body type identifier.</doc>
      <invoke>get_body</invoke>
    </method>
    <method>
      <name>getAbout</name>
      <return>
        <type>String</type>
      </return>
      <doc>Description.</doc>
      <invoke>get_about</invoke>
    </method>
    <method>
      <name>getDesc</name>
      <return>
        <type>String</type>
        <doc>Blueprint for the race description.</doc>
      </return>
      <doc>The output of this function should be passed through <link type="strParse"/>, with the player given as the entity.</doc>
      <invoke>get_desc</invoke>
    </method>
    <method>
      <name>getAverageHeight</name>
      <return>
        <type>Integer</type>
        <doc>Average height for the specified gender.  (Default is in inches, game authors may use centimeters instead.)</doc>
      </return>
      <arg>
        <type>Integer</type>
        <name>gender</name>
        <doc>The gender for which the average height of the race is desired.  Each gender may have a different average height.</doc>
      </arg>
      <code><![CDATA[
        if (_arg_gender >= 0 && _arg_gender < GenderType::COUNT)
          _return = _self->get_average_height(_arg_gender);
      ]]></code>
    </method>
  </type>
  <function>
    <name>getPlayerRace</name>
    <return>
      <type>PlayerRace</type>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
    </arg>
    <code>_return = RaceManager.get (_arg_name);</code>
    <doc>Find the player race with the given name.</doc>
    <invoke>Race::get</invoke>
  </function>
  <function>
    <name>getPlayerRaces</name>
    <return>
      <type>Iterator</type>
    </return>
    <iterdata>Race* race;</iterdata>
    <iternext><![CDATA[
      if (race != NULL) {
        _iterval = race;
        race = race->get_next();
        return true;
      } else {
        return false;
      }
    ]]></iternext>
    <iternew>race = RaceManager.first();</iternew>
    <code>_return = new _iterator();</code>
    <doc>Returns an iterator for all defined player races.</doc>
  </function>

  <!-- Entity Tag -->
  <type>
    <name>Tag</name>
    <cppwrap>TagID</cppwrap>
    <doc>Tags are used to mark <link type="Entity">Entities</link>.  Code can then make decisions based on which tags an <link type="Entity"/> has (or doesn't have).  You may also retrieve a list of all entities with a given tag.</doc>

    <method>
      <name>getName</name>
      <return>
        <type>String</type>
        <doc>The name of the tag.</doc>
      </return>
      <code>_return = TagID::nameof(_self->data());</code>
    </method>
  </type>
  <function>
    <name>getTag</name>
    <return>
      <type>Tag</type>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
    </arg>
    <doc>Looks up an existing tag with the given name.</doc>
    <code>_return = new Tag(TagID::lookup(_arg_name));</code>
  </function>
  <function>
    <name>createTag</name>
    <return>
      <type>Tag</type>
    </return>
    <arg>
      <name>name</name>
      <type>String</type>
    </arg>
    <doc>creates a new tag from the given name, or returns an existing tag if one already exists with the name.</doc>
    <code>_return = new Tag(TagID::create(_arg_name));</code>
  </function>

  <!-- GameTime -->
  <type>
    <name>Time</name>
    <cppwrap>GameTime</cppwrap>
    <doc>Tracks game time.  This type is usually stored in core data types as a copy.  For example, retrieving a player's birthday will _return = a copy of the data stored in the player.  Modifying the copy will not immediately modify the player's birthday.  Instead, the modified copy must be given back to the player to update it's version.  This is true for other core types that use Time.  Scriptix arrays and object properties will store a reference as usual.</doc>

    <!-- Make a copy -->
    <method>
      <name>copy</name>
      <return>
        <type>Time</type>
      </return>
      <doc>creates a new, separate copy of the Time object. This copy can be modified without altering the values of the original object.</doc>
      <code><![CDATA[
        _return = new Time (AweMUD_TimeType, _self->data());
      ]]></code>
    </method>

    <!-- Operate -->
    <method>
      <name>getYear</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>Fetch stored year.</doc>
      <code><![CDATA[
        _return = _self->data().get_year();
      ]]></code>
    </method>
    <method>
      <name>setYear</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>year</name>
        <type>Integer</type>
      </arg>
      <doc>Set year.  Returns the value after clipping/updating the time structure to match the calendar.</doc>
      <code><![CDATA[
        _return = _self->data().set_year(_arg_year);
      ]]></code>
    </method>
    <method>
      <name>getMonth</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>Fetch stored month.</doc>
      <code><![CDATA[
        _return = _self->data().get_month();
      ]]></code>
    </method>
    <method>
      <name>setMonth</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>month</name>
        <type>Integer</type>
      </arg>
      <doc>Set month.  Returns the value after clipping/updating the time structure to match the calendar.</doc>
      <code><![CDATA[
        _return = _self->data().set_month(_arg_month);
      ]]></code>
    </method>
    <method>
      <name>getDay</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>Fetch stored day.</doc>
      <code><![CDATA[
        _return = _self->data().get_day();
      ]]></code>
    </method>
    <method>
      <name>setDay</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>day</name>
        <type>Integer</type>
      </arg>
      <doc>Set day.  Returns the value after clipping/updating the time structure to match the calendar.</doc>
      <code><![CDATA[
        _return = _self->data().set_day(_arg_day);
      ]]></code>
    </method>
    <method>
      <name>getHour</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>Fetch stored hour.</doc>
      <code><![CDATA[
        _return = _self->data().get_hour();
      ]]></code>
    </method>
    <method>
      <name>setHour</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>hour</name>
        <type>Integer</type>
      </arg>
      <doc>Set hour.  Returns the value after clipping/updating the time structure to match the calendar.</doc>
      <code><![CDATA[
        _return = _self->data().set_hour(_arg_hour);
      ]]></code>
    </method>
    <method>
      <name>getTicks</name>
      <return>
        <type>Integer</type>
      </return>
      <doc>Fetch stored ticks.</doc>
      <code><![CDATA[
        _return = _self->data().get_ticks();
      ]]></code>
    </method>
    <method>
      <name>setTicks</name>
      <return>
        <type>Integer</type>
      </return>
      <arg>
        <name>ticks</name>
        <type>Integer</type>
      </arg>
      <doc>Set ticks.  Returns the value after clipping/updating the time structure to match the calendar.</doc>
      <code><![CDATA[
        _return = _self->data().set_ticks(_arg_ticks);
      ]]></code>
    </method>

    <method>
      <name>getDate</name>
      <return>
        <type>String</type>
      </return>
      <doc>Return the current date as a string.</doc>
      <code><![CDATA[
        char date_buf[40]; // should be big enough
        _self->data().date_str (date_buf, sizeof (date_buf));
        _return = String(date_buf);
      ]]></code>
    </method>

    <method>
      <name>getTime</name>
      <return>
        <type>String</type>
      </return>
      <doc>Return the current time as a string.</doc>
      <code><![CDATA[
        char time_buf[40]; // should be big enough
        _self->data().time_str (time_buf, sizeof (time_buf));
        _return = String(time_buf);
      ]]></code>
    </method>
  </type>

  <!-- Skill -->
  <type>
    <name>Skill</name>
    <cppname>SkillInfo</cppname>
    <doc>Skill represents an in-game skill.</doc>

    <method>
      <name>getName</name>
      <return>
        <type>String</type>
        <doc>Name of the skill.</doc>
      </return>
      <invoke>get_name</invoke>
    </method>
    <method>
      <name>getDesc</name>
      <invoke>get_desc</invoke>
      <return>
        <type>String</type>
        <doc>Description of the skill.</doc>
      </return>
    </method>
    
    <method>
      <name>isRestricted</name>
      <invoke>is_restricted</invoke>
      <return>
        <type>Boolean</type>
        <doc>True if the skill is restricted.</doc>
      </return>
      <doc>Restricted skills cannot be bought using the normal methods, although once a player has one or more ranks in the skill, the player may improve skill using the normal methods.</doc>
    </method>
    <method>
      <name>isLocked</name>
      <invoke>is_locked</invoke>
      <return>
        <type>Boolean</type>
        <doc>True if the skill is locked.</doc>
      </return>
      <doc>Locked skills cannot be bought or improved by the player using the normal methods.  Any skill which isLocked returns true for will also return true for isRestricted.</doc>
    </method>
    <method>
      <name>isIntrinsic</name>
      <invoke>is_intrinsic</invoke>
      <return>
        <type>Boolean</type>
        <doc>True if the skill is an instrinsic ability.</doc>
      </return>
      <doc>Intrinsic skills are usually called 'stats' or 'attributes' in other game systems.  Strength or intelligence are examples of intrinsic skills.  Intrinsic skills cannot be improved by the player using the normal methods.  They are also displayed separately from other skills and are handled differently during creature creation.  Any skill which isIntrinsic returns true for will also return for for isRestricted and isLocked.</doc>
    </method>
    <method>
      <name>isSecret</name>
      <invoke>is_secret</invoke>
      <return>
        <type>Boolean</type>
        <doc>True if the skill is secret.</doc>
      </return>
      <doc>Secret skills are locked skills which are hidden from the player entirely.  Any skill which isIntrinsic returns true for will also return for for isRestricted and isLocked.</doc>
    </method>
  </type>

  <!-- HTTP -->
  <type>
    <name>HTTP</name>
    <cppname>HTTPHandler</cppname>
    <doc>The HTTP object represents an HTTP connection.  This are one-off requests, which are used to script the AweMUD Portal interface.</doc>

    <!-- Display the page header/footer -->
    <method>
      <name>header</name>
      <doc>Display the default page header.</doc>
      <code><![CDATA[
        *_self << "HTTP/1.0 200 OK\nContent-type: text/html\n\n";
        *_self << StreamParse(HTTPManager.get_template(S("header")), S("account"), _self->get_account());
      ]]></code>
    </method>
    <method>
      <name>footer</name>
      <doc>Display the default page footer.</doc>
      <code><![CDATA[
        *_self << StreamParse(HTTPManager.get_template(S("footer")), S("account"), _self->get_account());
      ]]></code>
    </method>

    <!-- Redirect the browser -->
    <method>
      <name>redirect</name>
      <arg>
        <type>String</type>
        <name>url</name>
        <doc>The URL to redirect the user to.</doc>
      </arg>
      <doc>This method redirects the user's browser.  It's most useful after doing form processing successfully.</doc>
      <code><![CDATA[*_self << "HTTP/1.0 302 Temporary Redirect\nLocation: " << _arg_url << "\nContent-type: text/html\n\n<p><a href=\"" << _arg_url << "\">" << _arg_url << "</a></p>\n";]]></code>
    </method>

    <!-- Check if a session is active -->
    <method>
      <name>isSession</name>
      <return>
        <type>Boolean</type>
        <doc>True if there is a session open.</doc>
      </return>
      <doc>This method returns true if the current connection has an associated session.</doc>
      <code><![CDATA[_return = _self->get_session() != NULL;]]></code>
    </method>

    <!-- Auth checking -->
    <method>
      <name>checkAccess</name>
      <return>
        <type>Boolean</type>
        <doc>True if the requirement was passed.</doc>
      </return>
      <arg>
        <name>privilege</name>
        <type>String</type>
        <doc>The privilege which is required.</doc>
      </arg>
      <doc>This function tests if the currently logged in user (if any) has the requested privilege.</doc>
      <code><![CDATA[
        if (!_self->get_account() || !_self->get_account()->has_access(AccessID::lookup(_arg_privilege))) {
          _return = false;
        } else {
          _return = true;
        }
      ]]></code>
    </method>
    <method>
      <name>requireAccess</name>
      <return>
        <type>Boolean</type>
        <doc>True if the requirement was passed.</doc>
      </return>
      <arg>
        <name>privilege</name>
        <type>String</type>
        <doc>The privilege which is required.</doc>
      </arg>
      <doc>This function, like checkAccess, tests if the current logged in user (if any) has the associated privilege.  This function will also automatically display an access denied error if the requested privilege is not available, however.</doc>
      <code><![CDATA[
        if (!_self->get_account() || !_self->get_account()->has_access(AccessID::lookup(_arg_privilege))) {
          *_self << "HTTP/1.0 403 Access Denied\nContent-type: text/html\n\n";
          *_self << StreamParse(HTTPManager.get_template(S("header")), S("account"), _self->get_account());
          *_self << StreamParse(HTTPManager.get_template(S("noaccess")), S("account"), _self->get_account(), S("priv"), _arg_privilege);
          *_self << StreamParse(HTTPManager.get_template(S("footer")));
          _return = false;
        } else {
          _return = true;
        }
      ]]></code>
    </method>

    <!-- Set/get session variables -->
    <method>
      <name>setVar</name>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of the session variable to set.</doc>
      </arg>
      <arg>
        <type>String</type>
        <name>value</name>
        <doc>The value to set the session variable to.</doc>
      </arg>
      <doc>This will store the name/value pair with the HTTP session, and the values will be retained across page requests.  This will only work if the user is logged in and there is an active session.</doc>
      <code><![CDATA[if (_self->get_session()) _self->get_session()->set_var(_arg_name, _arg_value);]]></code>
    </method>
    <method>
      <name>getVar</name>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of the session variable to retrieve.</doc>
      </arg>
      <return>
        <type>String</type>
        <doc>The value of the session variable retrieved.  Will be nil if the variable is not set or there is no active session.</doc>
      </return>
      <doc>This will retrieve a value stored with setVar.</doc>
      <code><![CDATA[if (_self->get_session()) _return = _self->get_session()->get_var(_arg_name);]]></code>
    </method>

    <!-- request variables -->
    <method>
      <name>getRequest</name>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of the GET variable to retrieve.</doc>
      </arg>
      <return>
        <type>String</type>
        <doc>The value of the GET variable retrieved.  Will be nil if the variable is not set.</doc>
      </return>
      <doc>This will retrieve the requested GET variable from a form submission.</doc>
      <code><![CDATA[_return = _self->get_request(_arg_name);]]></code>
    </method>
    <method>
      <name>getPOST</name>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Name of the POST variable to retrieve.</doc>
      </arg>
      <return>
        <type>String</type>
        <doc>The value of the POST variable retrieved.  Will be nil if the variable is not set.</doc>
      </return>
      <doc>This will retrieve the requested POST variable from a form submission.</doc>
      <code><![CDATA[_return = _self->get_post(_arg_name);]]></code>
    </method>

    <!-- Display a particular template -->
    <method>
      <name>displayTemplate</name>
      <arg>
        <type>String</type>
        <name>name</name>
        <doc>Template to display.</doc>
      </arg>
      <doc>Displays a template to the user with the default expansions.</doc>
      <varg />
      <code><![CDATA[
        if (_argc % 2 != 0) {
          Scriptix::ScriptManager.raise_error(Scriptix::SXE_BADARGS, "Arguments to 'HTTP.displayTemplate()' must be in name/value pairs.");
          return Scriptix::Nil;
        }

        ParseArgs vlist;
        String name;
        vlist[S("http")] = _self;
        if (_self->get_session() != NULL)
          vlist[S("account")] = _self->get_session()->get_account();
        for (size_t i = 2; i < _argc; i += 2) {
          name = _argv[1].get_string();
          if (_argv[i + 1].is_a(AweMUD_EntityType)) {
            vlist[name] = ((Entity*)_argv[i + 1].get());
          } else {
            _argv[i + 1] = _argv[i + 1].to_string();
            if (!_argv[i].is_nil())
              vlist[name] = _argv[i + 1].get_string();
          }
        }
        parse::text(*_self, HTTPManager.get_template(_arg_name), vlist);
      ]]></code>
    </method>
  </type>
  <function>
    <name>registerPage</name>
    <arg>
      <name>name</name>
      <type>String</type>
      <doc>Page name.</doc>
    </arg>
    <arg>
      <name>callback</name>
      <type>Function</type>
      <doc>Callback function.  It must take the following arguments: page name (String) and connection (HTTP).</doc>
    </arg>
    <code><![CDATA[HTTPManager.register_page(_arg_name, _arg_callback);]]></code>
  </function>

  <!-- Telnet -->
  <type>
    <name>Telnet</name>
    <cppname>TelnetHandler</cppname>
    <doc>The Telnet object represents a connection to a user.  <link type="Player"/>) usually have a Telnet object (accessible with <link method="Player.getTelnet"/>) when active.  The Telnet object is most useful for ZMP operations.</doc>

    <!-- Send ZMP -->
    <method>
      <name>sendZmp</name>
      <arg>
        <name>command</name>
        <type>String</type>
        <doc>The ZMP command.</doc>
      </arg>
      <varg/>
      <doc>Issues a ZMP command to the client connection.</doc>
      <code><![CDATA[
        ZMPPack zmp(_arg_command);

        for (size_t i = 2; i < _argc; ++ i) {
          if (_argv[i].is_int()) {
            zmp.add(Scriptix::Number::to_int(_argv[i]));
          } else {
            zmp.add(Scriptix::Value(_argv[i].to_string()));
          }
        }

        zmp.send(_self);
      ]]></code>
    </method>
  </type>
  <function>
    <name>registerZMP</name>
    <arg>
      <name>command</name>
      <type>String</type>
      <doc>The name of the ZMP command being registered.</doc>
    </arg>
    <arg>
      <name>function</name>
      <type>Function</type>
      <doc>The function to be called for the command.</doc>
    </arg>
    <return>
      <type>Boolean</type>
      <doc>True on success, false on failure.</doc>
    </return>
    <doc>This method adds a new ZMP command handler.  The command will be invoked whenever a ZMP command is encountered by the telnet processor.  The function will be passed a Telnet object and an array of strings, which are the command arguments, including the command name.</doc>
    <code><![CDATA[
      _return = ZMPManager.add(_arg_command, _arg_function);
    ]]></code>
  </function>

  <!-- BUILTIN - ARRAY -->
  <function>
    <name>array</name>
    <return>
      <type>Array</type>
      <doc>A new Array filled with the input values.</doc>
    </return>
    <varg/>
    <doc>Creates a new array populated with the function's arguments.</doc>
    <code><![CDATA[
      return new Scriptix::Array(_argc, _argv);
    ]]></code>
  </function>
  <type>
    <name>Array</name>
    <doconly/>
    <doc>Arrays are lists of data.  An array can hold any number of arbitrary values.  Values in arrays can be fetched and stored using the array notation in Scriptix.  For example, number = array[10]; array[10] = "a string";</doc>
    <method>
      <name>length</name>
      <return>
        <type>Integer</type>
        <doc>The length of the array.  This is the number of values stores in the array.</doc>
      </return>
    </method>
    <method>
      <name>append</name>
      <arg>
        <type>Mixed</type>
        <name>value</name>
        <doc>The value to append to the array.</doc>
      </arg>
      <doc>The append method will add the given value to the end of the array, increasing the array's length by one.</doc>
    </method>
    <method>
      <name>remove</name>
      <arg>
        <type>Mixed</type>
        <name>value</name>
        <doc>The value to remove from the array.</doc>
      </arg>
      <doc>All instances of the value in the array are removed.  This may reduce the length of the array, and change the indexes of other values in the array.</doc>
    </method>
  </type>
  <!-- BUILTIN - INTEGER -->
  <type>
    <name>Integer</name>
    <doconly/>
    <doc>Integers are the fundamental numeric type in Scriptix.  An integer is any positive or negative number (or zero) in the range of -2^30 to +2^30.</doc>
    <method>
      <name>toStr</name>
      <return>
        <type>String</type>
        <doc>The textual representation of the integer.</doc>
      </return>
    </method>
  </type>
  <!-- BUILTIN - STRING -->
  <type>
    <name>String</name>
    <doconly/>
    <doc>Strings represent text.  Any series of creatures (letters, numbers, punctuation, whitespace, and so on) is represented as a string.  New arbitrary strings can be defined by putting the text in quotes, either double (") or single (').  Example string: "This is a string"</doc>
    <method>
      <name>length</name>
      <return>
        <type>Integer</type>
        <doc>Length of the string in characters.</doc>
      </return>
    </method>
    <method>
      <name>toInt</name>
      <return>
        <type>Integer</type>
        <doc>Numeric interpretation of the string.</doc>
      </return>
    </method>
    <method>
      <name>toUpper</name>
      <return>
        <type>String</type>
        <doc>A copy of the string with all characters upper-cased.</doc>
      </return>
    </method>
    <method>
      <name>toLower</name>
      <return>
        <type>String</type>
        <doc>A copy of the string with all characters lower-cased.</doc>
      </return>
    </method>
    <method>
      <name>substr</name>
      <return>
        <type>String</type>
        <doc>The request substring.</doc>
      </return>
      <arg>
        <type>Integer</type>
        <name>start</name>
        <doc>Creature index on which the susbtring shall begin.</doc>
      </arg>
      <arg>
        <type>Integer</type>
        <name>length</name>
        <doc>Length of the substring in characters.</doc>
      </arg>
      <doc>The substr method will create a substring of the base string.  For example, you can request the substring of "Hello" which starts at index 1 (the 'e') and is 2 characters long ("el").  If a substring is requested that is too long or out of bounds, the substring will be clipped appropriately.</doc>
    </method>
    <method>
      <name>split</name>
      <return>
        <type>Array</type>
        <doc>An array of the substrings.</doc>
      </return>
      <arg>
        <type>String</type>
        <name>separator</name>
        <doc>String on which to break apart the substrings of the base string.</doc>
      </arg>
      <doc>The split method will make an array of substrings from the base string, separated by the separator string.  For example, if you split the string "My name is Sean" on the string " " (a single space), you would receive the array ["My","name","is","Sean"].</doc>
    </method>
    <method>
      <name>trim</name>
      <return>
        <type>String</type>
        <doc>A copy of the string with all leading and trailing whitespace removed.</doc>
      </return>
    </method>
    <method>
      <name>ltrim</name>
      <return>
        <type>String</type>
        <doc>A copy of the string with all leading whitespace removed.</doc>
      </return>
    </method>
    <method>
      <name>rtrim</name>
      <return>
        <type>String</type>
        <doc>A copy of the string with all trailing whitespace removed.</doc>
      </return>
    </method>
    <method>
      <name>matches</name>
      <return>
        <type>Boolean</type>
        <doc>True if the string matches the test, and false otherwise.</doc>
      </return>
      <arg>
        <name>test</name>
        <type>String</type>
        <doc>String to test against.</doc>
      </arg>
      <doc>Performs a string match as if using the <link type="strMatch"/> function.  Returns <link global="true"/> if the string matches the test pattern, and <link global="false"/> otherwise.</doc>
    </method>
  </type>
  <!-- PHONY - BOOLEAN -->
  <type>
    <name>Boolean</name>
    <doconly/>
    <doc>Boolean values are either <link global="true"/> or <link global="false"/>.  The empty <link type="String"/>, empty <link type="Array"/>, <link type="Integer"/> zero, and nil values are all false, while all other values are true.</doc>
  </type>
  <!-- PHONY - MIXED -->
  <type>
    <name>Mixed</name>
    <doconly/>
    <doc>The mixed type is a psuedo-type, used in method and function arguments and return values that take more than one type of value.  Unless the documentation for a method or function states otherwise, any type of value may be used in place of a mixed type.</doc>
  </type>
  <!-- PHONY - _iteratorATOR -->
  <type>
    <name>Iterator</name>
    <doconly/>
    <doc>Iterators are special values used by the foreach looping statement in Scriptix.  Methods and functions returning iterators should only be used as values in foreach loop statements.  The data structures that iterators are based on should not be modified while in the foreach loop, as doing so may result in the foreach loop skipping or doubling up on values during its iteration.</doc>
  </type>
</script-interface>
<!-- vim: set filetype=xml shiftwidth=2 tabstop=2 expandtab : -->
