<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book id="script-guide">
  <?dbhtml file="index.html"?>
  <bookinfo>
    <title>AweMUD Scripting Guide</title>
  </bookinfo>

  <chapter id="ch_intro">
    <title>Introduction</title>
    <warning>THIS DOCUMENT IS EXTREMELY OUT-OF-DATE!</warning>
    <para>AweMUD makes use of the Scriptix language to extend and modify the behaviour of the core engine.  This guide gives a short over-view of using Scriptix with AweMUD.  We do not attempt to teach the Scriptix language in this document (that is the job of yet-to-be-written Scritpix Programming Manual).</para>
    <section>
      <title>Using Scriptix</title>
      <para>When AweMUD boots up, it loads all the scripts found in the Scriptix folder (./scripts/ by default).  Each of these scripts is compiled into bytecode for use by AweMUD.  You cannot, at this time, specify the order scripts are loaded, ignore scripts in the Scriptix folder, or load scripts after AweMUD has booted.</para>
    </section>
  </chapter>
  <chapter id="ch_commands">
    <title>Commands</title>
    <para>One of the many abilities Scriptix has in AweMUD is to register new commands.  A command is what a player types in when playing to game to perform actions or query the server for information.</para>
    <section>
      <title>Command Functions</title>
      <para>Functions used in Scriptix for commands will receive two parameters: the <link linkend="Character">character</link> who entered the command and an array of the command's parsed arguments, as strings.</para>
      <para>Command functions should return a boolean (integer) value.  A true (non-zero, non-nil) value means the command was valid, and a false (zero or nil) return value means the command was invalid.  This causes the interpreter to continue looking for more command matches.  This will allow you to make commands that can "dynamically" hide and unhide themselves.</para>
      <para>Take for example a command to teleport to a home location.  Let's call the command <command>home</command>.  Commands like these are popular for assisting newbies in getting used to the game.  However, we only want this command to be usable by newbies; more powerful/experiences players shouldn't be able to use it.  We could simply have the command print out a "You are not a newbie" message for experienced players that try to use the command; however, the command will still "clash" with other commands when short-cutting (for example, an experienced player may type <userinput>h</userinput> for a <command>hack</command> command, and end up triggering the newbie command).</para>
      <para>If the newbie command instead remains silent, and returns a false value instead, the command parser will continue looking for more command matches, and find the <command>hack</command> as expected.</para>
      <example><title>A basic command handler.</title>
        <programlisting><![CDATA[command
  dance (who, args)
  {
    // information to append to dance output
    out = nil;

    // check argument type
    if (args[0]) {
      if (args[0] == 'happily') {
        out = ' like a happy fool!';
      } else if (args[0] == 'drunkenly') {
        out = ' sloppily across the room, like a drunkard!';
      } else if (args[0] == 'vigorously') {
        out = ' vigorously.  Tango time!';
      }
    }

    // what do we print
    if (out) {
      who.print('You dance ', out, "\n");
      who.rprint(who, ' dances ', out, "\n");
    } else {
      who.print("You dance about.\n");
      who.rprint(who, " dances about.\n");
    }
  }]]></programlisting>
      </example>
    </section>
    <section>
      <title>Registering Commands</title>
      <para>In order to AweMUD to know about your command function, you must register the command with the command interpreter.  This is done using the <link linkend="registerCommand">registerCommand()</link> function.  This function is a little complex; it takes a number of arguments.</para>
      <para>The first three are solely for documentation and book keeping purposes.  Each command must have an official name.  This is almost always the same as the first word of the command.  I.e., the <command>dance</command> example about would be named <userinput>"dance"</userinput>.  The second parameter is a short about string.  The about string should briefly describe what the command does.  The third argument is a list of usage lines.  Usage lines are in the format <userinput>"foo &lt;argument:&gt;\n"</userinput>.  The newline is mandatory.  You may put in multiple usage lines if your command has multiple formats.</para>
      <para>The next argument is the most complex.  The fourth argument is the format string for the command.  The format string tells the command parser how to interpret the command, and how to extract the interesting arguments for the argv[] array passed to the command function.  Formatting is described in more detail below.  You may pass in either a single string, or an array of strings, for the format argument.</para>
      <para>The final two bits are simple enough.  The fifth parameter is the actual function to call for the command.  The final parameter is the necessary permission level required to use the command.  The constants <constant>PRIV_PLAYER</constant> and friends can be used here.  If you want to allow any character to use a command, use the permission level of 0 (zero).</para>
    </section>
    <section>
      <title>Command Formats</title>
      <para>Command formats are special strings that tell the command parser what a command looks like.  This generally consists of a word, usually the command name, and several arguments.</para>
      <para>The parser understands three kinds of inputs: Text, Word, and String.  Text is any static text, such as <userinput>dance</userinput> or <userinput>home</userinput>.  Word is any single arbitrary word.  String is one or more arbitrary Words.</para>
      <para>To specify Text, simply put the requisite text in the format string.  To specify a Word is needed, put in a % (percent sign).  To specify a String is needed, specify a * (star).  Note that a String can only be followed by Text, and not a Word.</para>
      <example><title>Dance command, takes a single word for argument.</title>
        <para><userinput>"dance %"</userinput></para>
      </example>
      <para>It's also possible to specify that an argument is optional.  For example, our <command>dance</command> command may be used without any arguments.  It's possible to specify two command formats, one with the argument, and one without.  It's much easier and more efficient, however, to simply tell the parser that our argument is optional.  We do this by prefixing the argument with a ? (question mark).  Note that Text, as well as Words and Strings, may be made optional.</para>
      <example><title>Dance with optional argument.</title>
        <para><userinput>"dance ?%"</userinput></para>
      </example>
      <para>Now, of course, our dance command wants to know what word was used.  We must tell the command parser that we want the argument put in the first argv[] element.  Remember, in Scriptix, that array indexes start at 0 (zero).  In order to tell the parser where to put an argument, prefix the argument with a : (colon), followed by the index to use.  Indexes must not be negative, and must be less than 10.  (One digit only.)</para>
      <example><title>Dance command with argument in argv[0].</title>
        <para><userinput>"dance ?:0%"</userinput></para>
      </example>
      <para>And that is it for command parsing.  Here are some more complex commands; try to determine what they are intended to parse as.</para>
      <example><title>Complex command formats.</title>
        <para><userinput>"tell :0% :1*"</userinput></para>
        <para><userinput>"put :0* :1in :2*"</userinput></para>
        <para><userinput>"create :0exit :1% to :2%"</userinput></para>
      </example>
    </section>
  </chapter>
  <chapter id="npc_ai">
    <title>NPC AI</title>
    <para>AI, or artificial intelligence, allows a script coder to define and control and NPCs behaviour.  This behaviour may be as simple or as complex as one wishes.</para>
    <para>The AI system in AweMUD is based entirely on <link linkend="ch_events">events</link>.  NPCs receive both events intended for themselves, and events which occur in the room they are in.  For example, an NPC will receive <link linkend="event_enter">enter</link> events whenever a new NPC or Player enters the room.  The AI may dictate that the NPC nod at any who enter, for example.</para>
    <para>The AI system also provides specializations for two particular events: the heartbeat, and the roundtime expiration.  Round time expiration is useful mainly for combat purposes, as it allows the NPC to immediately react when the roundtime has expired.  The heartbeat reaction is usually used in conjuction with counters to implement random or intermittent behaviour; for example, to have the NPC hum once every 15 seconds.</para>
  </chapter>

  <!-- include API reference -->
  <xi:include href="../doc/script-ref.xml" xpointer="xpointer(/script-reference/*)" parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude" />

  <!-- include Event reference -->
  <xi:include href="../doc/event-ref.xml" xpointer="xpointer(/event-reference/*)" parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude" />

  <!-- include hook reference -->
  <xi:include href="../doc/hook-ref.xml" xpointer="xpointer(/hook-reference/*)" parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude" />

</book>
<!-- vim: set filetype=xml shiftwidth=2 tabstop=2 expandtab : -->
